{"name":"Init.Grind.Tactics","instances":[{"typeNames":["Lean.Grind.Config"],"name":"Lean.Grind.instInhabitedConfig","className":"Inhabited"},{"typeNames":["Lean.Grind.Config"],"name":"Lean.Grind.instBEqConfig","className":"BEq"}],"imports":["Init.Grind.Attr","Init.Core"],"declarations":[{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/7c3ca70e29a0806bd4bfc62eae7084bbaf1a303d/src/Init/Grind/Tactics.lean#L404-L412","name":"Lean.Parser.Tactic.grindTrace","line":404,"kind":"def","docLink":"./Init/Grind/Tactics.html#Lean.Parser.Tactic.grindTrace","doc":"`grind?` takes the same arguments as `grind`, but reports an equivalent call to `grind only`\nthat would be sufficient to close the goal. This is useful for reducing the size of the `grind`\ntheorems in a local invocation.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Grind/Tactics.html#Lean.Parser.Tactic.grindTrace\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">grindTrace</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/7c3ca70e29a0806bd4bfc62eae7084bbaf1a303d/src/Init/Grind/Tactics.lean#L132-L402","name":"Lean.Parser.Tactic.grind","line":132,"kind":"def","docLink":"./Init/Grind/Tactics.html#Lean.Parser.Tactic.grind","doc":"`grind` is a tactic inspired by modern SMT solvers. **Picture a virtual whiteboard**:\nevery time grind discovers a new equality, inequality, or logical fact,\nit writes it on the board, groups together terms known to be equal,\nand lets each reasoning engine read from and contribute to the shared workspace.\nThese engines work together to handle equality reasoning, apply known theorems,\npropagate new facts, perform case analysis, and run specialized solvers\nfor domains like linear arithmetic and commutative rings.\n\n`grind` is *not* designed for goals whose search space explodes combinatorially,\nthink large pigeonhole instances, graph‑coloring reductions, high‑order N‑queens boards,\nor a 200‑variable Sudoku encoded as Boolean constraints.  Such encodings require\n thousands (or millions) of case‑splits that overwhelm `grind`’s branching search.\n\nFor **bit‑level or combinatorial problems**, consider using **`bv_decide`**.\n`bv_decide` calls a state‑of‑the‑art SAT solver (CaDiCaL) and then returns a\n*compact, machine‑checkable certificate*.\n\n### Equality reasoning\n\n`grind` uses **congruence closure** to track equalities between terms.\nWhen two terms are known to be equal, congruence closure automatically deduces\nequalities between more complex expressions built from them.\nFor example, if `a = b`, then congruence closure will also conclude that `f a` = `f b`\nfor any function `f`. This forms the foundation for efficient equality reasoning in `grind`.\nHere is an example:\n```\nexample (f : Nat → Nat) (h : a = b) : f (f b) = f (f a) := by\n  grind\n```\n\n### Applying theorems using E-matching\n\nTo apply existing theorems, `grind` uses a technique called **E-matching**,\nwhich finds matches for known theorem patterns while taking equalities into account.\nCombined with congruence closure, E-matching helps `grind` discover\nnon-obvious consequences of theorems and equalities automatically.\n\nConsider the following functions and theorems:\n```\ndef f (a : Nat) : Nat :=\n  a + 1\n\ndef g (a : Nat) : Nat :=\n  a - 1\n\n@[grind =]\ntheorem gf (x : Nat) : g (f x) = x := by\n  simp [f, g]\n```\nThe theorem `gf` asserts that `g (f x) = x` for all natural numbers `x`.\nThe attribute `[grind =]` instructs `grind` to use the left-hand side of the equation,\n`g (f x)`, as a pattern for E-matching.\nSuppose we now have a goal involving:\n```\nexample {a b} (h : f b = a) : g a = b := by\n  grind\n```\nAlthough `g a` is not an instance of the pattern `g (f x)`,\nit becomes one modulo the equation `f b = a`. By substituting `a`\nwith `f b` in `g a`, we obtain the term `g (f b)`,\nwhich matches the pattern `g (f x)` with the assignment `x := b`.\nThus, the theorem `gf` is instantiated with `x := b`,\nand the new equality `g (f b) = b` is asserted.\n`grind` then uses congruence closure to derive the implied equality\n`g a = g (f b)` and completes the proof.\n\nThe pattern used to instantiate theorems affects the effectiveness of `grind`.\nFor example, the pattern `g (f x)` is too restrictive in the following case:\nthe theorem `gf` will not be instantiated because the goal does not even\ncontain the function symbol `g`.\n\n```\nexample (h₁ : f b = a) (h₂ : f c = a) : b = c := by\n  grind\n```\n\nYou can use the command `grind_pattern` to manually select a pattern for a given theorem.\nIn the following example, we instruct `grind` to use `f x` as the pattern,\nallowing it to solve the goal automatically:\n```\ngrind_pattern gf => f x\n\nexample {a b c} (h₁ : f b = a) (h₂ : f c = a) : b = c := by\n  grind\n```\nYou can enable the option `trace.grind.ematch.instance` to make `grind` print a\ntrace message for each theorem instance it generates.\n\nYou can also specify a **multi-pattern** to control when `grind` should apply a theorem.\nA multi-pattern requires that all specified patterns are matched in the current context\nbefore the theorem is applied. This is useful for theorems such as transitivity rules,\nwhere multiple premises must be simultaneously present for the rule to apply.\nThe following example demonstrates this feature using a transitivity axiom for a binary relation `R`:\n```\nopaque R : Int → Int → Prop\naxiom Rtrans {x y z : Int} : R x y → R y z → R x z\n\ngrind_pattern Rtrans => R x y, R y z\n\nexample {a b c d} : R a b → R b c → R c d → R a d := by\n  grind\n```\nBy specifying the multi-pattern `R x y, R y z`, we instruct `grind` to\ninstantiate `Rtrans` only when both `R x y` and `R y z` are available in the context.\nIn the example, `grind` applies `Rtrans` to derive `R a c` from `R a b` and `R b c`,\nand can then repeat the same reasoning to deduce `R a d` from `R a c` and `R c d`.\n\nInstead of using `grind_pattern` to explicitly specify a pattern,\nyou can use the `@[grind]` attribute or one of its variants, which will use a heuristic to\ngenerate a (multi-)pattern. The complete list is available in the reference manual. The main ones are:\n\n- `@[grind →]` will select a multi-pattern from the hypotheses of the theorem (i.e. it will use the theorem for forwards reasoning).\n  In more detail, it will traverse the hypotheses of the theorem from left-to-right, and each time it encounters a minimal indexable\n  (i.e. has a constant as its head) subexpression which \"covers\" (i.e. fixes the value of) an argument which was not\n  previously covered, it will add that subexpression as a pattern, until all arguments have been covered.\n- `@[grind ←]` will select a multi-pattern from the conclusion of theorem (i.e. it will use the theorem for backwards reasoning).\n  This may fail if not all the arguments to the theorem appear in the conclusion.\n- `@[grind]` will traverse the conclusion and then the hypotheses left-to-right, adding patterns as they increase the coverage,\n  stopping when all arguments are covered.\n- `@[grind =]` checks that the conclusion of the theorem is an equality, and then uses the left-hand-side of the equality as a pattern.\n  This may fail if not all of the arguments appear in the left-hand-side.\n\nHere is the previous example again but using the attribute `[grind →]`\n```\nopaque R : Int → Int → Prop\n@[grind →] axiom Rtrans {x y z : Int} : R x y → R y z → R x z\n\nexample {a b c d} : R a b → R b c → R c d → R a d := by\n  grind\n```\n\nTo control theorem instantiation and avoid generating an unbounded number of instances,\n`grind` uses a generation counter. Terms in the original goal are assigned generation zero.\nWhen `grind` applies a theorem using terms of generation `≤ n`, any new terms it creates\nare assigned generation `n + 1`. This limits how far the tactic explores when applying\ntheorems and helps prevent an excessive number of instantiations.\n\n#### Key options:\n- `grind (ematch := <num>)` controls the number of E-matching rounds.\n- `grind [<name>, ...]` instructs `grind` to use the declaration `name` during E-matching.\n- `grind only [<name>, ...]` is like `grind [<name>, ...]` but does not use theorems tagged with `@[grind]`.\n- `grind (gen := <num>)` sets the maximum generation.\n\n### Linear integer arithmetic (`cutsat`)\n\n`grind` can solve goals that reduce to **linear integer arithmetic (LIA)** using an\nintegrated decision procedure called **`cutsat`**.  It understands\n\n* equalities   `p = 0`\n* inequalities  `p ≤ 0`\n* disequalities `p ≠ 0`\n* divisibility  `d ∣ p`\n\nThe solver incrementally assigns integer values to variables; when a partial\nassignment violates a constraint it adds a new, implied constraint and retries.\nThis *model-based* search is **complete for LIA**.\n\n#### Key options:\n\n* `grind -cutsat` disable the solver (useful for debugging)\n* `grind +qlia` accept rational models (shrinks the search space but is incomplete for ℤ)\n\n#### Examples:\n\n```\n-- Even + even is never odd.\nexample {x y : Int} : 2 * x + 4 * y ≠ 5 := by\n  grind\n\n-- Mixing equalities and inequalities.\nexample {x y : Int} :\n    2 * x + 3 * y = 0 → 1 ≤ x → y < 1 := by\n  grind\n\n-- Reasoning with divisibility.\nexample (a b : Int) :\n    2 ∣ a + 1 → 2 ∣ b + a → ¬ 2 ∣ b + 2 * a := by\n  grind\n\nexample (x y : Int) :\n    27 ≤ 11*x + 13*y →\n    11*x + 13*y ≤ 45 →\n    -10 ≤ 7*x - 9*y →\n    7*x - 9*y ≤ 4 → False := by\n  grind\n\n-- Types that implement the `ToInt` type-class.\nexample (a b c : UInt64)\n    : a ≤ 2 → b ≤ 3 → c - a - b = 0 → c ≤ 5 := by\n  grind\n```\n\n### Algebraic solver (`ring`)\n\n`grind` ships with an algebraic solver nick-named **`ring`** for goals that can\nbe phrased as polynomial equations (or disequations) over commutative rings,\nsemirings, or fields.\n\n*Works out of the box*\nAll core numeric types and relevant Mathlib types already provide the required\ntype-class instances, so the solver is ready to use in most developments.\n\nWhat it can decide:\n\n* equalities of the form `p = q`\n* disequalities `p ≠ q`\n* basic reasoning under field inverses (`a / b := a * b⁻¹`)\n* goals that mix ring facts with other `grind` engines\n\n#### Key options:\n\n* `grind -ring` turn the solver off (useful when debugging)\n* `grind (ringSteps := n)` cap the number of steps performed by this procedure.\n\n#### Examples\n\n```\nopen Lean Grind\n\nexample [CommRing α] (x : α) : (x + 1) * (x - 1) = x^2 - 1 := by\n  grind\n\n-- Characteristic 256 means 16 * 16 = 0.\nexample [CommRing α] [IsCharP α 256] (x : α) :\n    (x + 16) * (x - 16) = x^2 := by\n  grind\n\n-- Works on built-in rings such as `UInt8`.\nexample (x : UInt8) : (x + 16) * (x - 16) = x^2 := by\n  grind\n\nexample [CommRing α] (a b c : α) :\n    a + b + c = 3 →\n    a^2 + b^2 + c^2 = 5 →\n    a^3 + b^3 + c^3 = 7 →\n    a^4 + b^4 = 9 - c^4 := by\n  grind\n\nexample [Field α] [NoNatZeroDivisors α] (a : α) :\n    1 / a + 1 / (2 * a) = 3 / (2 * a) := by\n  grind\n```\n\n### Other options\n\n- `grind (splits := <num>)` caps the *depth* of the search tree.  Once a branch performs `num` splits\n  `grind` stops splitting further in that branch.\n- `grind -splitIte` disables case splitting on if-then-else expressions.\n- `grind -splitMatch` disables case splitting on `match` expressions.\n- `grind +splitImp` instructs `grind` to split on any hypothesis `A → B` whose antecedent `A` is **propositional**.\n- `grind -linarith` disables the linear arithmetic solver for (ordered) modules and rings.\n\n### Additional Examples\n\n```\nexample {a b} {as bs : List α} : (as ++ bs ++ [b]).getLastD a = b := by\n  grind\n\nexample (x : BitVec (w+1)) : (BitVec.cons x.msb (x.setWidth w)) = x := by\n  grind\n\nexample (as : Array α) (lo hi i j : Nat) :\n    lo ≤ i → i < j → j ≤ hi → j < as.size → min lo (as.size - 1) ≤ i := by\n  grind\n```\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Grind/Tactics.html#Lean.Parser.Tactic.grind\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">grind</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/7c3ca70e29a0806bd4bfc62eae7084bbaf1a303d/src/Init/Grind/Tactics.lean#L130-L130","name":"Lean.Parser.Tactic.grindParam","line":130,"kind":"def","docLink":"./Init/Grind/Tactics.html#Lean.Parser.Tactic.grindParam","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Grind/Tactics.html#Lean.Parser.Tactic.grindParam\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">grindParam</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/7c3ca70e29a0806bd4bfc62eae7084bbaf1a303d/src/Init/Grind/Tactics.lean#L129-L129","name":"Lean.Parser.Tactic.grindLemma","line":129,"kind":"def","docLink":"./Init/Grind/Tactics.html#Lean.Parser.Tactic.grindLemma","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Grind/Tactics.html#Lean.Parser.Tactic.grindLemma\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">grindLemma</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/7c3ca70e29a0806bd4bfc62eae7084bbaf1a303d/src/Init/Grind/Tactics.lean#L128-L128","name":"Lean.Parser.Tactic.grindErase","line":128,"kind":"def","docLink":"./Init/Grind/Tactics.html#Lean.Parser.Tactic.grindErase","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Grind/Tactics.html#Lean.Parser.Tactic.grindErase\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">grindErase</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/7c3ca70e29a0806bd4bfc62eae7084bbaf1a303d/src/Init/Grind/Tactics.lean#L118-L118","name":"Lean.Grind.instBEqConfig","line":118,"kind":"instance","docLink":"./Init/Grind/Tactics.html#Lean.Grind.instBEqConfig","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Grind/Tactics.html#Lean.Grind.instBEqConfig\"><span class=\"name\">Lean</span>.<span class=\"name\">Grind</span>.<span class=\"name\">instBEqConfig</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#BEq\">BEq</a> <a href=\"./Init/Grind/Tactics.html#Lean.Grind.Config\">Config</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/7c3ca70e29a0806bd4bfc62eae7084bbaf1a303d/src/Init/Grind/Tactics.lean#L118-L118","name":"Lean.Grind.instInhabitedConfig","line":118,"kind":"instance","docLink":"./Init/Grind/Tactics.html#Lean.Grind.instInhabitedConfig","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Grind/Tactics.html#Lean.Grind.instInhabitedConfig\"><span class=\"name\">Lean</span>.<span class=\"name\">Grind</span>.<span class=\"name\">instInhabitedConfig</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Inhabited\">Inhabited</a> <a href=\"./Init/Grind/Tactics.html#Lean.Grind.Config\">Config</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/7c3ca70e29a0806bd4bfc62eae7084bbaf1a303d/src/Init/Grind/Tactics.lean#L117-L117","name":"Lean.Grind.Config.cutsat","line":117,"kind":"def","docLink":"./Init/Grind/Tactics.html#Lean.Grind.Config.cutsat","doc":"When `true` (default: `true`), uses procedure for handling linear integer arithmetic for `Int` and `Nat`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Grind/Tactics.html#Lean.Grind.Config.cutsat\"><span class=\"name\">Lean</span>.<span class=\"name\">Grind</span>.<span class=\"name\">Config</span>.<span class=\"name\">cutsat</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Init/Grind/Tactics.html#Lean.Grind.Config\">Config</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Bool\">Bool</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/7c3ca70e29a0806bd4bfc62eae7084bbaf1a303d/src/Init/Grind/Tactics.lean#L113-L113","name":"Lean.Grind.Config.linarith","line":113,"kind":"def","docLink":"./Init/Grind/Tactics.html#Lean.Grind.Config.linarith","doc":"When `true` (default: `true`), uses procedure for handling linear arithmetic for `IntModule`, and\n`CommRing`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Grind/Tactics.html#Lean.Grind.Config.linarith\"><span class=\"name\">Lean</span>.<span class=\"name\">Grind</span>.<span class=\"name\">Config</span>.<span class=\"name\">linarith</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Init/Grind/Tactics.html#Lean.Grind.Config\">Config</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Bool\">Bool</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/7c3ca70e29a0806bd4bfc62eae7084bbaf1a303d/src/Init/Grind/Tactics.lean#L108-L108","name":"Lean.Grind.Config.ringNull","line":108,"kind":"def","docLink":"./Init/Grind/Tactics.html#Lean.Grind.Config.ringNull","doc":"When `true` (default: `false`), the commutative ring procedure in `grind` constructs stepwise\nproof terms, instead of a single-step Nullstellensatz certificate\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Grind/Tactics.html#Lean.Grind.Config.ringNull\"><span class=\"name\">Lean</span>.<span class=\"name\">Grind</span>.<span class=\"name\">Config</span>.<span class=\"name\">ringNull</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Init/Grind/Tactics.html#Lean.Grind.Config\">Config</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Bool\">Bool</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/7c3ca70e29a0806bd4bfc62eae7084bbaf1a303d/src/Init/Grind/Tactics.lean#L103-L103","name":"Lean.Grind.Config.ringSteps","line":103,"kind":"def","docLink":"./Init/Grind/Tactics.html#Lean.Grind.Config.ringSteps","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Grind/Tactics.html#Lean.Grind.Config.ringSteps\"><span class=\"name\">Lean</span>.<span class=\"name\">Grind</span>.<span class=\"name\">Config</span>.<span class=\"name\">ringSteps</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Init/Grind/Tactics.html#Lean.Grind.Config\">Config</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Nat\">Nat</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/7c3ca70e29a0806bd4bfc62eae7084bbaf1a303d/src/Init/Grind/Tactics.lean#L102-L102","name":"Lean.Grind.Config.ring","line":102,"kind":"def","docLink":"./Init/Grind/Tactics.html#Lean.Grind.Config.ring","doc":"When `true` (default: `true`), uses procedure for handling equalities over commutative rings.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Grind/Tactics.html#Lean.Grind.Config.ring\"><span class=\"name\">Lean</span>.<span class=\"name\">Grind</span>.<span class=\"name\">Config</span>.<span class=\"name\">ring</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Init/Grind/Tactics.html#Lean.Grind.Config\">Config</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Bool\">Bool</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/7c3ca70e29a0806bd4bfc62eae7084bbaf1a303d/src/Init/Grind/Tactics.lean#L98-L98","name":"Lean.Grind.Config.zeta","line":98,"kind":"def","docLink":"./Init/Grind/Tactics.html#Lean.Grind.Config.zeta","doc":"When `true` (default: `true`), performs zeta reduction of let expressions during normalization.\nThat is, `let x := v; e[x]` reduces to `e[v]`. See also `zetaDelta`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Grind/Tactics.html#Lean.Grind.Config.zeta\"><span class=\"name\">Lean</span>.<span class=\"name\">Grind</span>.<span class=\"name\">Config</span>.<span class=\"name\">zeta</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Init/Grind/Tactics.html#Lean.Grind.Config\">Config</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Bool\">Bool</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/7c3ca70e29a0806bd4bfc62eae7084bbaf1a303d/src/Init/Grind/Tactics.lean#L93-L93","name":"Lean.Grind.Config.zetaDelta","line":93,"kind":"def","docLink":"./Init/Grind/Tactics.html#Lean.Grind.Config.zetaDelta","doc":"When set to `true` (default: `true`), local definitions are unfolded during normalization and internalization.\nIn other words, given a local context with an entry `x : t := e`, the free variable `x` is reduced to `e`.\nNote that this behavior is also available in `simp`, but there its default is `false` because `simp` is not\nalways used as a terminal tactic, and it important to preserve the abstractions introduced by users.\nAdditionally, in `grind` we observed that `zetaDelta` is particularly important when combined with function induction.\nIn such scenarios, the same let-expressions can be introduced by function induction and also by unfolding the\ncorresponding definition. We want to avoid a situation in which `zetaDelta` is not applied to let-declarations\nintroduced by function induction while `zeta` unfolds the definition, causing a mismatch.\nFinally, note that congruence closure is less effective on terms containing many binders such as\n`lambda` and `let` expressions.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Grind/Tactics.html#Lean.Grind.Config.zetaDelta\"><span class=\"name\">Lean</span>.<span class=\"name\">Grind</span>.<span class=\"name\">Config</span>.<span class=\"name\">zetaDelta</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Init/Grind/Tactics.html#Lean.Grind.Config\">Config</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Bool\">Bool</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/7c3ca70e29a0806bd4bfc62eae7084bbaf1a303d/src/Init/Grind/Tactics.lean#L80-L80","name":"Lean.Grind.Config.mbtc","line":80,"kind":"def","docLink":"./Init/Grind/Tactics.html#Lean.Grind.Config.mbtc","doc":"If `mbtc` is `true`, `grind` will use model-based theory combination for creating new case splits.\nSee paper \"Model-based Theory Combination\" for details.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Grind/Tactics.html#Lean.Grind.Config.mbtc\"><span class=\"name\">Lean</span>.<span class=\"name\">Grind</span>.<span class=\"name\">Config</span>.<span class=\"name\">mbtc</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Init/Grind/Tactics.html#Lean.Grind.Config\">Config</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Bool\">Bool</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/7c3ca70e29a0806bd4bfc62eae7084bbaf1a303d/src/Init/Grind/Tactics.lean#L75-L75","name":"Lean.Grind.Config.qlia","line":75,"kind":"def","docLink":"./Init/Grind/Tactics.html#Lean.Grind.Config.qlia","doc":"If `qlia` is `true`, `grind` may generate counterexamples for integer constraints\nusing rational numbers, and ignoring divisibility constraints.\nThis approach is cheaper but incomplete. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Grind/Tactics.html#Lean.Grind.Config.qlia\"><span class=\"name\">Lean</span>.<span class=\"name\">Grind</span>.<span class=\"name\">Config</span>.<span class=\"name\">qlia</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Init/Grind/Tactics.html#Lean.Grind.Config\">Config</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Bool\">Bool</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/7c3ca70e29a0806bd4bfc62eae7084bbaf1a303d/src/Init/Grind/Tactics.lean#L70-L70","name":"Lean.Grind.Config.clean","line":70,"kind":"def","docLink":"./Init/Grind/Tactics.html#Lean.Grind.Config.clean","doc":"If `clean` is `true`, `grind` uses `expose_names` and only generates accessible names. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Grind/Tactics.html#Lean.Grind.Config.clean\"><span class=\"name\">Lean</span>.<span class=\"name\">Grind</span>.<span class=\"name\">Config</span>.<span class=\"name\">clean</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Init/Grind/Tactics.html#Lean.Grind.Config\">Config</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Bool\">Bool</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/7c3ca70e29a0806bd4bfc62eae7084bbaf1a303d/src/Init/Grind/Tactics.lean#L68-L68","name":"Lean.Grind.Config.verbose","line":68,"kind":"def","docLink":"./Init/Grind/Tactics.html#Lean.Grind.Config.verbose","doc":"If `verbose` is `false`, additional diagnostics information is not collected. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Grind/Tactics.html#Lean.Grind.Config.verbose\"><span class=\"name\">Lean</span>.<span class=\"name\">Grind</span>.<span class=\"name\">Config</span>.<span class=\"name\">verbose</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Init/Grind/Tactics.html#Lean.Grind.Config\">Config</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Bool\">Bool</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/7c3ca70e29a0806bd4bfc62eae7084bbaf1a303d/src/Init/Grind/Tactics.lean#L66-L66","name":"Lean.Grind.Config.lookahead","line":66,"kind":"def","docLink":"./Init/Grind/Tactics.html#Lean.Grind.Config.lookahead","doc":"TODO "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Grind/Tactics.html#Lean.Grind.Config.lookahead\"><span class=\"name\">Lean</span>.<span class=\"name\">Grind</span>.<span class=\"name\">Config</span>.<span class=\"name\">lookahead</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Init/Grind/Tactics.html#Lean.Grind.Config\">Config</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Bool\">Bool</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/7c3ca70e29a0806bd4bfc62eae7084bbaf1a303d/src/Init/Grind/Tactics.lean#L64-L64","name":"Lean.Grind.Config.funext","line":64,"kind":"def","docLink":"./Init/Grind/Tactics.html#Lean.Grind.Config.funext","doc":"If `funext` is `true`, `grind` creates new opportunities for applying function extensionality by case-splitting\non equalities between lambda expressions.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Grind/Tactics.html#Lean.Grind.Config.funext\"><span class=\"name\">Lean</span>.<span class=\"name\">Grind</span>.<span class=\"name\">Config</span>.<span class=\"name\">funext</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Init/Grind/Tactics.html#Lean.Grind.Config\">Config</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Bool\">Bool</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/7c3ca70e29a0806bd4bfc62eae7084bbaf1a303d/src/Init/Grind/Tactics.lean#L59-L59","name":"Lean.Grind.Config.etaStruct","line":59,"kind":"def","docLink":"./Init/Grind/Tactics.html#Lean.Grind.Config.etaStruct","doc":"If `etaStruct` is `true`, then for each term `t : S` such that `S` is a structure,\nand is tagged with `[grind ext]`, `grind` adds the equation `t = ⟨t.1, ..., t.n⟩`\nwhich holds by reflexivity. Moreover, the extensionality theorem for `S` is not used.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Grind/Tactics.html#Lean.Grind.Config.etaStruct\"><span class=\"name\">Lean</span>.<span class=\"name\">Grind</span>.<span class=\"name\">Config</span>.<span class=\"name\">etaStruct</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Init/Grind/Tactics.html#Lean.Grind.Config\">Config</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Bool\">Bool</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/7c3ca70e29a0806bd4bfc62eae7084bbaf1a303d/src/Init/Grind/Tactics.lean#L53-L53","name":"Lean.Grind.Config.extAll","line":53,"kind":"def","docLink":"./Init/Grind/Tactics.html#Lean.Grind.Config.extAll","doc":"If `extAll` is `true`, `grind` uses any extensionality theorems available in the environment. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Grind/Tactics.html#Lean.Grind.Config.extAll\"><span class=\"name\">Lean</span>.<span class=\"name\">Grind</span>.<span class=\"name\">Config</span>.<span class=\"name\">extAll</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Init/Grind/Tactics.html#Lean.Grind.Config\">Config</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Bool\">Bool</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/7c3ca70e29a0806bd4bfc62eae7084bbaf1a303d/src/Init/Grind/Tactics.lean#L51-L51","name":"Lean.Grind.Config.ext","line":51,"kind":"def","docLink":"./Init/Grind/Tactics.html#Lean.Grind.Config.ext","doc":"If `ext` is `true`, `grind` uses extensionality theorems that have been marked with `[grind ext]`. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Grind/Tactics.html#Lean.Grind.Config.ext\"><span class=\"name\">Lean</span>.<span class=\"name\">Grind</span>.<span class=\"name\">Config</span>.<span class=\"name\">ext</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Init/Grind/Tactics.html#Lean.Grind.Config\">Config</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Bool\">Bool</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/7c3ca70e29a0806bd4bfc62eae7084bbaf1a303d/src/Init/Grind/Tactics.lean#L49-L49","name":"Lean.Grind.Config.canonHeartbeats","line":49,"kind":"def","docLink":"./Init/Grind/Tactics.html#Lean.Grind.Config.canonHeartbeats","doc":"Maximum number of heartbeats (in thousands) the canonicalizer can spend per definitional equality test. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Grind/Tactics.html#Lean.Grind.Config.canonHeartbeats\"><span class=\"name\">Lean</span>.<span class=\"name\">Grind</span>.<span class=\"name\">Config</span>.<span class=\"name\">canonHeartbeats</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Init/Grind/Tactics.html#Lean.Grind.Config\">Config</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Nat\">Nat</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/7c3ca70e29a0806bd4bfc62eae7084bbaf1a303d/src/Init/Grind/Tactics.lean#L47-L47","name":"Lean.Grind.Config.splitImp","line":47,"kind":"def","docLink":"./Init/Grind/Tactics.html#Lean.Grind.Config.splitImp","doc":"If `splitImp` is `true`, then given an implication `p → q` or `(h : p) → q h`, `grind` splits on `p`\nif the implication is true. Otherwise, it will split only if `p` is an arithmetic predicate.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Grind/Tactics.html#Lean.Grind.Config.splitImp\"><span class=\"name\">Lean</span>.<span class=\"name\">Grind</span>.<span class=\"name\">Config</span>.<span class=\"name\">splitImp</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Init/Grind/Tactics.html#Lean.Grind.Config\">Config</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Bool\">Bool</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/7c3ca70e29a0806bd4bfc62eae7084bbaf1a303d/src/Init/Grind/Tactics.lean#L42-L42","name":"Lean.Grind.Config.splitIndPred","line":42,"kind":"def","docLink":"./Init/Grind/Tactics.html#Lean.Grind.Config.splitIndPred","doc":"If `splitIndPred` is `true`, `grind` performs case-splitting on inductive predicates.\nOtherwise, it performs case-splitting only on types marked with `[grind cases]` attribute. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Grind/Tactics.html#Lean.Grind.Config.splitIndPred\"><span class=\"name\">Lean</span>.<span class=\"name\">Grind</span>.<span class=\"name\">Config</span>.<span class=\"name\">splitIndPred</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Init/Grind/Tactics.html#Lean.Grind.Config\">Config</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Bool\">Bool</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/7c3ca70e29a0806bd4bfc62eae7084bbaf1a303d/src/Init/Grind/Tactics.lean#L38-L38","name":"Lean.Grind.Config.splitIte","line":38,"kind":"def","docLink":"./Init/Grind/Tactics.html#Lean.Grind.Config.splitIte","doc":"If `splitIte` is `true`, `grind` performs case-splitting on `if-then-else` expressions during the search. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Grind/Tactics.html#Lean.Grind.Config.splitIte\"><span class=\"name\">Lean</span>.<span class=\"name\">Grind</span>.<span class=\"name\">Config</span>.<span class=\"name\">splitIte</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Init/Grind/Tactics.html#Lean.Grind.Config\">Config</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Bool\">Bool</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/7c3ca70e29a0806bd4bfc62eae7084bbaf1a303d/src/Init/Grind/Tactics.lean#L36-L36","name":"Lean.Grind.Config.splitMatch","line":36,"kind":"def","docLink":"./Init/Grind/Tactics.html#Lean.Grind.Config.splitMatch","doc":"If `splitMatch` is `true`, `grind` performs case-splitting on `match`-expressions during the search. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Grind/Tactics.html#Lean.Grind.Config.splitMatch\"><span class=\"name\">Lean</span>.<span class=\"name\">Grind</span>.<span class=\"name\">Config</span>.<span class=\"name\">splitMatch</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Init/Grind/Tactics.html#Lean.Grind.Config\">Config</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Bool\">Bool</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/7c3ca70e29a0806bd4bfc62eae7084bbaf1a303d/src/Init/Grind/Tactics.lean#L34-L34","name":"Lean.Grind.Config.matchEqs","line":34,"kind":"def","docLink":"./Init/Grind/Tactics.html#Lean.Grind.Config.matchEqs","doc":"If `matchEqs` is `true`, `grind` uses `match`-equations as E-matching theorems. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Grind/Tactics.html#Lean.Grind.Config.matchEqs\"><span class=\"name\">Lean</span>.<span class=\"name\">Grind</span>.<span class=\"name\">Config</span>.<span class=\"name\">matchEqs</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Init/Grind/Tactics.html#Lean.Grind.Config\">Config</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Bool\">Bool</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/7c3ca70e29a0806bd4bfc62eae7084bbaf1a303d/src/Init/Grind/Tactics.lean#L32-L32","name":"Lean.Grind.Config.instances","line":32,"kind":"def","docLink":"./Init/Grind/Tactics.html#Lean.Grind.Config.instances","doc":"Maximum number of theorem instances generated using E-matching in a proof search tree branch. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Grind/Tactics.html#Lean.Grind.Config.instances\"><span class=\"name\">Lean</span>.<span class=\"name\">Grind</span>.<span class=\"name\">Config</span>.<span class=\"name\">instances</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Init/Grind/Tactics.html#Lean.Grind.Config\">Config</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Nat\">Nat</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/7c3ca70e29a0806bd4bfc62eae7084bbaf1a303d/src/Init/Grind/Tactics.lean#L30-L30","name":"Lean.Grind.Config.gen","line":30,"kind":"def","docLink":"./Init/Grind/Tactics.html#Lean.Grind.Config.gen","doc":"Maximum term generation.\nThe input goal terms have generation 0. When we instantiate a theorem using a term from generation `n`,\nthe new terms have generation `n+1`. Thus, this parameter limits the length of an instantiation chain. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Grind/Tactics.html#Lean.Grind.Config.gen\"><span class=\"name\">Lean</span>.<span class=\"name\">Grind</span>.<span class=\"name\">Config</span>.<span class=\"name\">gen</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Init/Grind/Tactics.html#Lean.Grind.Config\">Config</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Nat\">Nat</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/7c3ca70e29a0806bd4bfc62eae7084bbaf1a303d/src/Init/Grind/Tactics.lean#L25-L25","name":"Lean.Grind.Config.ematch","line":25,"kind":"def","docLink":"./Init/Grind/Tactics.html#Lean.Grind.Config.ematch","doc":"Maximum number of E-matching (aka heuristic theorem instantiation) rounds before each case split. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Grind/Tactics.html#Lean.Grind.Config.ematch\"><span class=\"name\">Lean</span>.<span class=\"name\">Grind</span>.<span class=\"name\">Config</span>.<span class=\"name\">ematch</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Init/Grind/Tactics.html#Lean.Grind.Config\">Config</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Nat\">Nat</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/7c3ca70e29a0806bd4bfc62eae7084bbaf1a303d/src/Init/Grind/Tactics.lean#L23-L23","name":"Lean.Grind.Config.splits","line":23,"kind":"def","docLink":"./Init/Grind/Tactics.html#Lean.Grind.Config.splits","doc":"Maximum number of case-splits in a proof search branch. It does not include splits performed during normalization. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Grind/Tactics.html#Lean.Grind.Config.splits\"><span class=\"name\">Lean</span>.<span class=\"name\">Grind</span>.<span class=\"name\">Config</span>.<span class=\"name\">splits</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Init/Grind/Tactics.html#Lean.Grind.Config\">Config</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Nat\">Nat</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/7c3ca70e29a0806bd4bfc62eae7084bbaf1a303d/src/Init/Grind/Tactics.lean#L21-L21","name":"Lean.Grind.Config.trace","line":21,"kind":"def","docLink":"./Init/Grind/Tactics.html#Lean.Grind.Config.trace","doc":"If `trace` is `true`, `grind` records used E-matching theorems and case-splits. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Grind/Tactics.html#Lean.Grind.Config.trace\"><span class=\"name\">Lean</span>.<span class=\"name\">Grind</span>.<span class=\"name\">Config</span>.<span class=\"name\">trace</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Init/Grind/Tactics.html#Lean.Grind.Config\">Config</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Bool\">Bool</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/7c3ca70e29a0806bd4bfc62eae7084bbaf1a303d/src/Init/Grind/Tactics.lean#L19-L19","name":"Lean.Grind.Config.mk","line":19,"kind":"ctor","docLink":"./Init/Grind/Tactics.html#Lean.Grind.Config.mk","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Grind/Tactics.html#Lean.Grind.Config.mk\"><span class=\"name\">Lean</span>.<span class=\"name\">Grind</span>.<span class=\"name\">Config</span>.<span class=\"name\">mk</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">trace</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">splits </span><span class=\"fn\">ematch </span><span class=\"fn\">gen </span><span class=\"fn\">instances</span> : <a href=\"./Init/Prelude.html#Nat\">Nat</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">matchEqs </span><span class=\"fn\">splitMatch </span><span class=\"fn\">splitIte </span><span class=\"fn\">splitIndPred </span><span class=\"fn\">splitImp</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">canonHeartbeats</span> : <a href=\"./Init/Prelude.html#Nat\">Nat</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">ext </span><span class=\"fn\">extAll </span><span class=\"fn\">etaStruct </span><span class=\"fn\">funext </span><span class=\"fn\">lookahead </span><span class=\"fn\">verbose </span><span class=\"fn\">clean </span><span class=\"fn\">qlia </span><span class=\"fn\">mbtc </span><span class=\"fn\">zetaDelta </span><span class=\"fn\">zeta </span><span class=\"fn\">ring</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">ringSteps</span> : <a href=\"./Init/Prelude.html#Nat\">Nat</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">ringNull </span><span class=\"fn\">linarith </span><span class=\"fn\">cutsat</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Grind/Tactics.html#Lean.Grind.Config\">Config</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/7c3ca70e29a0806bd4bfc62eae7084bbaf1a303d/src/Init/Grind/Tactics.lean#L15-L118","name":"Lean.Grind.Config","line":15,"kind":"structure","docLink":"./Init/Grind/Tactics.html#Lean.Grind.Config","doc":"The configuration for `grind`.\nPassed to `grind` using, for example, the `grind (config := { matchEqs := true })` syntax.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">structure</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Init/Grind/Tactics.html#Lean.Grind.Config\"><span class=\"name\">Lean</span>.<span class=\"name\">Grind</span>.<span class=\"name\">Config</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>"}]}