{"name":"Lean.Meta.Eqns","instances":[{"typeNames":["Lean.Meta.EqnsExtState"],"name":"Lean.Meta.instInhabitedEqnsExtState","className":"Inhabited"}],"imports":["Lean.ReservedNameAction","Lean.AddDecl","Lean.Meta.Basic","Lean.Meta.AppBuilder","Lean.Meta.Match.MatcherInfo","Lean.DefEqAttrib","Lean.Meta.LetToHave"],"declarations":[{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/7c3ca70e29a0806bd4bfc62eae7084bbaf1a303d/src/Lean/Meta/Eqns.lean#L293-L317","name":"Lean.Meta.getUnfoldEqnFor?","line":293,"kind":"def","docLink":"./Lean/Meta/Eqns.html#Lean.Meta.getUnfoldEqnFor?","doc":"Returns an \"unfold\" theorem (`f.eq_def`) for the given declaration.\nBy default, we do not create unfold theorems for nonrecursive definitions.\nYou can use `nonRec := true` to override this behavior.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Eqns.html#Lean.Meta.getUnfoldEqnFor?\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">getUnfoldEqnFor?</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">declName</span> : <a href=\"./Init/Prelude.html#Lean.Name\">Name</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">nonRec</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a> := <a href=\"./Init/Prelude.html#Bool.false\">false</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Init/Prelude.html#Lean.Name\">Name</a>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/7c3ca70e29a0806bd4bfc62eae7084bbaf1a303d/src/Lean/Meta/Eqns.lean#L263-L291","name":"Lean.Meta.registerGetUnfoldEqnFn","line":263,"kind":"def","docLink":"./Lean/Meta/Eqns.html#Lean.Meta.registerGetUnfoldEqnFn","doc":"Registers a new function for retrieving a \"unfold\" equation theorem.\n\nWe generate this kind of equation theorem on demand, and it is generated by more than one module.\nFor example, the structural and well-founded recursion modules generate it.\nMost recent getters are tried first.\n\nA getter returns an `Option Name`. The result is `none` if the getter failed.\nOtherwise, it is a theorem name. Example: the definition\n\n```\ndef f (xs : List Nat) : List Nat :=\n  match xs with\n  | [] => []\n  | x::xs => (x+1)::f xs\n```\nshould have the theorem\n```\n(xs : Nat) →\n  f xs =\n    match xs with\n    | [] => []\n    | x::xs => (x+1)::f xs\n```\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Eqns.html#Lean.Meta.registerGetUnfoldEqnFn\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">registerGetUnfoldEqnFn</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">f</span> : <a href=\"./Lean/Meta/Eqns.html#Lean.Meta.GetUnfoldEqnFn\">GetUnfoldEqnFn</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/System/IO.html#IO\">IO</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/7c3ca70e29a0806bd4bfc62eae7084bbaf1a303d/src/Lean/Meta/Eqns.lean#L259-L259","name":"Lean.Meta.GetUnfoldEqnFn","line":259,"kind":"def","docLink":"./Lean/Meta/Eqns.html#Lean.Meta.GetUnfoldEqnFn","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Eqns.html#Lean.Meta.GetUnfoldEqnFn\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">GetUnfoldEqnFn</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/7c3ca70e29a0806bd4bfc62eae7084bbaf1a303d/src/Lean/Meta/Eqns.lean#L250-L257","name":"Lean.Meta.generateEagerEqns","line":250,"kind":"def","docLink":"./Lean/Meta/Eqns.html#Lean.Meta.generateEagerEqns","doc":"If any equation theorem affecting option is not the default value, create the equations now.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Eqns.html#Lean.Meta.generateEagerEqns\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">generateEagerEqns</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">declName</span> : <a href=\"./Init/Prelude.html#Lean.Name\">Name</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/7c3ca70e29a0806bd4bfc62eae7084bbaf1a303d/src/Lean/Meta/Eqns.lean#L241-L248","name":"Lean.Meta.getEqnsFor?","line":241,"kind":"def","docLink":"./Lean/Meta/Eqns.html#Lean.Meta.getEqnsFor?","doc":"Returns equation theorems for the given declaration.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Eqns.html#Lean.Meta.getEqnsFor?\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">getEqnsFor?</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">declName</span> : <a href=\"./Init/Prelude.html#Lean.Name\">Name</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Option\">Option</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Init/Prelude.html#Lean.Name\">Name</a>)</span>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/7c3ca70e29a0806bd4bfc62eae7084bbaf1a303d/src/Lean/Meta/Eqns.lean#L197-L201","name":"Lean.Meta.isEqnThm","line":197,"kind":"def","docLink":"./Lean/Meta/Eqns.html#Lean.Meta.isEqnThm","doc":"Returns `true` if `thmName` is an equational theorem.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Eqns.html#Lean.Meta.isEqnThm\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">isEqnThm</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">thmName</span> : <a href=\"./Init/Prelude.html#Lean.Name\">Name</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/CoreM.html#Lean.Core.CoreM\">CoreM</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/7c3ca70e29a0806bd4bfc62eae7084bbaf1a303d/src/Lean/Meta/Eqns.lean#L191-L195","name":"Lean.Meta.isEqnThm?","line":191,"kind":"def","docLink":"./Lean/Meta/Eqns.html#Lean.Meta.isEqnThm?","doc":"Returns `some declName` if `thmName` is an equational theorem for `declName`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Eqns.html#Lean.Meta.isEqnThm?\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">isEqnThm?</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">thmName</span> : <a href=\"./Init/Prelude.html#Lean.Name\">Name</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/CoreM.html#Lean.Core.CoreM\">CoreM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Init/Prelude.html#Lean.Name\">Name</a>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/7c3ca70e29a0806bd4bfc62eae7084bbaf1a303d/src/Lean/Meta/Eqns.lean#L164-L166","name":"Lean.Meta.eqnsExt","line":164,"kind":"opaque","docLink":"./Lean/Meta/Eqns.html#Lean.Meta.eqnsExt","doc":"A mapping from equational theorem to the declaration it was derived from.  "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">opaque</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Eqns.html#Lean.Meta.eqnsExt\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">eqnsExt</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Environment.html#Lean.EnvExtension\">EnvExtension</a> <a href=\"./Lean/Meta/Eqns.html#Lean.Meta.EqnsExtState\">EqnsExtState</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/7c3ca70e29a0806bd4bfc62eae7084bbaf1a303d/src/Lean/Meta/Eqns.lean#L162-L162","name":"Lean.Meta.instInhabitedEqnsExtState","line":162,"kind":"instance","docLink":"./Lean/Meta/Eqns.html#Lean.Meta.instInhabitedEqnsExtState","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Eqns.html#Lean.Meta.instInhabitedEqnsExtState\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">instInhabitedEqnsExtState</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Inhabited\">Inhabited</a> <a href=\"./Lean/Meta/Eqns.html#Lean.Meta.EqnsExtState\">EqnsExtState</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/7c3ca70e29a0806bd4bfc62eae7084bbaf1a303d/src/Lean/Meta/Eqns.lean#L161-L161","name":"Lean.Meta.EqnsExtState.mapInv","line":161,"kind":"def","docLink":"./Lean/Meta/Eqns.html#Lean.Meta.EqnsExtState.mapInv","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Eqns.html#Lean.Meta.EqnsExtState.mapInv\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">EqnsExtState</span>.<span class=\"name\">mapInv</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Lean/Meta/Eqns.html#Lean.Meta.EqnsExtState\">EqnsExtState</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Data/PersistentHashMap.html#Lean.PHashMap\">PHashMap</a> <a href=\"./Init/Prelude.html#Lean.Name\">Name</a> <a href=\"./Init/Prelude.html#Lean.Name\">Name</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/7c3ca70e29a0806bd4bfc62eae7084bbaf1a303d/src/Lean/Meta/Eqns.lean#L160-L160","name":"Lean.Meta.EqnsExtState.mk","line":160,"kind":"ctor","docLink":"./Lean/Meta/Eqns.html#Lean.Meta.EqnsExtState.mk","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Eqns.html#Lean.Meta.EqnsExtState.mk\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">EqnsExtState</span>.<span class=\"name\">mk</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">mapInv</span> : <span class=\"fn\"><a href=\"./Lean/Data/PersistentHashMap.html#Lean.PHashMap\">PHashMap</a> <a href=\"./Init/Prelude.html#Lean.Name\">Name</a> <a href=\"./Init/Prelude.html#Lean.Name\">Name</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Meta/Eqns.html#Lean.Meta.EqnsExtState\">EqnsExtState</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/7c3ca70e29a0806bd4bfc62eae7084bbaf1a303d/src/Lean/Meta/Eqns.lean#L159-L162","name":"Lean.Meta.EqnsExtState","line":159,"kind":"structure","docLink":"./Lean/Meta/Eqns.html#Lean.Meta.EqnsExtState","doc":"A mapping from equational theorem to the declaration it was derived from.  "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">structure</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Eqns.html#Lean.Meta.EqnsExtState\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">EqnsExtState</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/7c3ca70e29a0806bd4bfc62eae7084bbaf1a303d/src/Lean/Meta/Eqns.lean#L122-L150","name":"Lean.Meta.registerGetEqnsFn","line":122,"kind":"def","docLink":"./Lean/Meta/Eqns.html#Lean.Meta.registerGetEqnsFn","doc":"Registers a new function for retrieving equation theorems.\nWe generate equations theorems on demand, and they are generated by more than one module.\nFor example, the structural and well-founded recursion modules generate them.\nMost recent getters are tried first.\n\nA getter returns an `Option (Array Name)`. The result is `none` if the getter failed.\nOtherwise, it is a sequence of theorem names where each one of them corresponds to\nan alternative. Example: the definition\n\n```\ndef f (xs : List Nat) : List Nat :=\n  match xs with\n  | [] => []\n  | x::xs => (x+1)::f xs\n```\nshould have two equational theorems associated with it\n```\nf [] = []\n```\nand\n```\n(x : Nat) → (xs : List Nat) → f (x :: xs) = (x+1) :: f xs\n```\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Eqns.html#Lean.Meta.registerGetEqnsFn\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">registerGetEqnsFn</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">f</span> : <a href=\"./Lean/Meta/Eqns.html#Lean.Meta.GetEqnsFn\">GetEqnsFn</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/System/IO.html#IO\">IO</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/7c3ca70e29a0806bd4bfc62eae7084bbaf1a303d/src/Lean/Meta/Eqns.lean#L118-L118","name":"Lean.Meta.GetEqnsFn","line":118,"kind":"def","docLink":"./Lean/Meta/Eqns.html#Lean.Meta.GetEqnsFn","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Eqns.html#Lean.Meta.GetEqnsFn\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">GetEqnsFn</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/7c3ca70e29a0806bd4bfc62eae7084bbaf1a303d/src/Lean/Meta/Eqns.lean#L96-L102","name":"Lean.Meta.ensureEqnReservedNamesAvailable","line":96,"kind":"def","docLink":"./Lean/Meta/Eqns.html#Lean.Meta.ensureEqnReservedNamesAvailable","doc":"Throw an error if names for equation theorems for `declName` are not available.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Eqns.html#Lean.Meta.ensureEqnReservedNamesAvailable\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">ensureEqnReservedNamesAvailable</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">declName</span> : <a href=\"./Init/Prelude.html#Lean.Name\">Name</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/CoreM.html#Lean.Core.CoreM\">CoreM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/7c3ca70e29a0806bd4bfc62eae7084bbaf1a303d/src/Lean/Meta/Eqns.lean#L90-L94","name":"Lean.Meta.mkEqLikeNameFor","line":90,"kind":"def","docLink":"./Lean/Meta/Eqns.html#Lean.Meta.mkEqLikeNameFor","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Eqns.html#Lean.Meta.mkEqLikeNameFor\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">mkEqLikeNameFor</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">env</span> : <a href=\"./Lean/Environment.html#Lean.Environment\">Environment</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">declName</span> : <a href=\"./Init/Prelude.html#Lean.Name\">Name</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">suffix</span> : <a href=\"./Init/Prelude.html#String\">String</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.Name\">Name</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/7c3ca70e29a0806bd4bfc62eae7084bbaf1a303d/src/Lean/Meta/Eqns.lean#L77-L88","name":"Lean.Meta.declFromEqLikeName","line":77,"kind":"def","docLink":"./Lean/Meta/Eqns.html#Lean.Meta.declFromEqLikeName","doc":"The equational theorem for a definition can be private even if the definition itself is not.\nSo un-private the name here when looking for a declaration\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Eqns.html#Lean.Meta.declFromEqLikeName\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">declFromEqLikeName</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">env</span> : <a href=\"./Lean/Environment.html#Lean.Environment\">Environment</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">name</span> : <a href=\"./Init/Prelude.html#Lean.Name\">Name</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> (<a href=\"./Init/Prelude.html#Lean.Name\">Name</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Init/Prelude.html#String\">String</a>)</span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/7c3ca70e29a0806bd4bfc62eae7084bbaf1a303d/src/Lean/Meta/Eqns.lean#L74-L75","name":"Lean.Meta.isEqnLikeSuffix","line":74,"kind":"def","docLink":"./Lean/Meta/Eqns.html#Lean.Meta.isEqnLikeSuffix","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Eqns.html#Lean.Meta.isEqnLikeSuffix\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">isEqnLikeSuffix</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">s</span> : <a href=\"./Init/Prelude.html#String\">String</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Bool\">Bool</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/7c3ca70e29a0806bd4bfc62eae7084bbaf1a303d/src/Lean/Meta/Eqns.lean#L72-L72","name":"Lean.Meta.eqUnfoldThmSuffix","line":72,"kind":"def","docLink":"./Lean/Meta/Eqns.html#Lean.Meta.eqUnfoldThmSuffix","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Eqns.html#Lean.Meta.eqUnfoldThmSuffix\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">eqUnfoldThmSuffix</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#String\">String</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/7c3ca70e29a0806bd4bfc62eae7084bbaf1a303d/src/Lean/Meta/Eqns.lean#L71-L71","name":"Lean.Meta.unfoldThmSuffix","line":71,"kind":"def","docLink":"./Lean/Meta/Eqns.html#Lean.Meta.unfoldThmSuffix","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Eqns.html#Lean.Meta.unfoldThmSuffix\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">unfoldThmSuffix</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#String\">String</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/7c3ca70e29a0806bd4bfc62eae7084bbaf1a303d/src/Lean/Meta/Eqns.lean#L67-L69","name":"Lean.Meta.isEqnReservedNameSuffix","line":67,"kind":"def","docLink":"./Lean/Meta/Eqns.html#Lean.Meta.isEqnReservedNameSuffix","doc":"Returns `true` if `s` is of the form `eq_<idx>` "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Eqns.html#Lean.Meta.isEqnReservedNameSuffix\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">isEqnReservedNameSuffix</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">s</span> : <a href=\"./Init/Prelude.html#String\">String</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Bool\">Bool</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/7c3ca70e29a0806bd4bfc62eae7084bbaf1a303d/src/Lean/Meta/Eqns.lean#L64-L64","name":"Lean.Meta.eqn1ThmSuffix","line":64,"kind":"def","docLink":"./Lean/Meta/Eqns.html#Lean.Meta.eqn1ThmSuffix","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Eqns.html#Lean.Meta.eqn1ThmSuffix\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">eqn1ThmSuffix</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#String\">String</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/7c3ca70e29a0806bd4bfc62eae7084bbaf1a303d/src/Lean/Meta/Eqns.lean#L63-L63","name":"Lean.Meta.eqnThmSuffixBasePrefix","line":63,"kind":"def","docLink":"./Lean/Meta/Eqns.html#Lean.Meta.eqnThmSuffixBasePrefix","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Eqns.html#Lean.Meta.eqnThmSuffixBasePrefix\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">eqnThmSuffixBasePrefix</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#String\">String</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/7c3ca70e29a0806bd4bfc62eae7084bbaf1a303d/src/Lean/Meta/Eqns.lean#L62-L62","name":"Lean.Meta.eqnThmSuffixBase","line":62,"kind":"def","docLink":"./Lean/Meta/Eqns.html#Lean.Meta.eqnThmSuffixBase","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Eqns.html#Lean.Meta.eqnThmSuffixBase\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">eqnThmSuffixBase</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#String\">String</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/7c3ca70e29a0806bd4bfc62eae7084bbaf1a303d/src/Lean/Meta/Eqns.lean#L56-L60","name":"Lean.Meta.isRecursiveDefinition","line":56,"kind":"def","docLink":"./Lean/Meta/Eqns.html#Lean.Meta.isRecursiveDefinition","doc":"Returns `true` if `declName` was defined using well-founded recursion, or structural recursion.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Eqns.html#Lean.Meta.isRecursiveDefinition\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">isRecursiveDefinition</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">declName</span> : <a href=\"./Init/Prelude.html#Lean.Name\">Name</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/CoreM.html#Lean.Core.CoreM\">CoreM</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/7c3ca70e29a0806bd4bfc62eae7084bbaf1a303d/src/Lean/Meta/Eqns.lean#L50-L54","name":"Lean.Meta.markAsRecursive","line":50,"kind":"def","docLink":"./Lean/Meta/Eqns.html#Lean.Meta.markAsRecursive","doc":"Marks the given declaration as recursive.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Eqns.html#Lean.Meta.markAsRecursive\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">markAsRecursive</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">declName</span> : <a href=\"./Init/Prelude.html#Lean.Name\">Name</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/CoreM.html#Lean.Core.CoreM\">CoreM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/7c3ca70e29a0806bd4bfc62eae7084bbaf1a303d/src/Lean/Meta/Eqns.lean#L42-L48","name":"Lean.Meta.recExt","line":42,"kind":"opaque","docLink":"./Lean/Meta/Eqns.html#Lean.Meta.recExt","doc":"Environment extension for storing which declarations are recursive.\nThis information is populated by the `PreDefinition` module, but the simplifier\nuses when unfolding declarations.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">opaque</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Eqns.html#Lean.Meta.recExt\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">recExt</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/EnvExtension.html#Lean.TagDeclarationExtension\">TagDeclarationExtension</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/7c3ca70e29a0806bd4bfc62eae7084bbaf1a303d/src/Lean/Meta/Eqns.lean#L32-L40","name":"Lean.Meta.eqnAffectingOptions","line":32,"kind":"def","docLink":"./Lean/Meta/Eqns.html#Lean.Meta.eqnAffectingOptions","doc":"These options affect the generation of equational theorems in a significant way. For these, their\nvalue at definition time, not realization time, should matter.\n\nThis is implemented by\n * eagerly realizing the equations when they are set to a non-default value\n * when realizing them lazily, reset the options to their default\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Eqns.html#Lean.Meta.eqnAffectingOptions\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">eqnAffectingOptions</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <span class=\"fn\">(<a href=\"./Lean/Data/Options.html#Lean.Option\">Lean.Option</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/7c3ca70e29a0806bd4bfc62eae7084bbaf1a303d/src/Lean/Meta/Eqns.lean#L22-L29","name":"Lean.Meta.backward.eqns.deepRecursiveSplit","line":22,"kind":"opaque","docLink":"./Lean/Meta/Eqns.html#Lean.Meta.backward.eqns.deepRecursiveSplit","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">opaque</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Eqns.html#Lean.Meta.backward.eqns.deepRecursiveSplit\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">backward</span>.<span class=\"name\">eqns</span>.<span class=\"name\">deepRecursiveSplit</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Data/Options.html#Lean.Option\">Lean.Option</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/7c3ca70e29a0806bd4bfc62eae7084bbaf1a303d/src/Lean/Meta/Eqns.lean#L17-L20","name":"Lean.Meta.backward.eqns.nonrecursive","line":17,"kind":"opaque","docLink":"./Lean/Meta/Eqns.html#Lean.Meta.backward.eqns.nonrecursive","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">opaque</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Lean/Meta/Eqns.html#Lean.Meta.backward.eqns.nonrecursive\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">backward</span>.<span class=\"name\">eqns</span>.<span class=\"name\">nonrecursive</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Data/Options.html#Lean.Option\">Lean.Option</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a></span></div></div>"}]}