{"name":"Std.Tactic.Do.Syntax","instances":[{"typeNames":["Lean.Parser.Tactic.MCasesPat"],"name":"Lean.Parser.Tactic.instReprMCasesPat","className":"Repr"},{"typeNames":["Lean.Parser.Tactic.MCasesPat"],"name":"Lean.Parser.Tactic.instInhabitedMCasesPat","className":"Inhabited"},{"typeNames":["Lean.Parser.Tactic.MRefinePat"],"name":"Lean.Parser.Tactic.instReprMRefinePat","className":"Repr"},{"typeNames":["Lean.Parser.Tactic.MRefinePat"],"name":"Lean.Parser.Tactic.instInhabitedMRefinePat","className":"Inhabited"}],"imports":["Std.Do","Init.NotationExtra","Std.Tactic.Do.ProofMode"],"declarations":[{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/7c3ca70e29a0806bd4bfc62eae7084bbaf1a303d/src/Std/Tactic/Do/Syntax.lean#L232-L237","name":"Lean.Parser.Tactic.mvcgenStep","line":232,"kind":"def","docLink":"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mvcgenStep","doc":"Like `mvcgen_no_trivial`, but `mvcgen_step 42` will only do 42 steps of the VC generation procedure.\nThis is helpful for bisecting bugs in `mvcgen` and tracing its execution.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mvcgenStep\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">mvcgenStep</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/7c3ca70e29a0806bd4bfc62eae7084bbaf1a303d/src/Std/Tactic/Do/Syntax.lean#L226-L230","name":"Lean.Parser.Tactic.mvcgenNoTrivial","line":226,"kind":"def","docLink":"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mvcgenNoTrivial","doc":"Like `mvcgen`, but does not attempt to prove trivial VCs via `mpure_intro; trivial`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mvcgenNoTrivial\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">mvcgenNoTrivial</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/7c3ca70e29a0806bd4bfc62eae7084bbaf1a303d/src/Std/Tactic/Do/Syntax.lean#L222-L224","name":"Lean.Parser.Tactic.mvcgen","line":222,"kind":"def","docLink":"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mvcgen","doc":"`mvcgen` will break down a Hoare triple proof goal like `⦃P⦄ prog ⦃Q⦄` into verification conditions,\nprovided that all functions used in `prog` have specifications registered with `@[spec]`.\n\nA verification condition is an entailment in the stateful logic of `Std.Do.SPred`\nin which the original program `prog` no longer occurs.\nVerification conditions are introduced by the `mspec` tactic; see the `mspec` tactic for what they\nlook like.\nWhen there's no applicable `mspec` spec, `mvcgen` will try and rewrite an application\n`prog = f a b c` with the simp set registered via `@[spec]`.\n\nWhen used like `mvcgen +noLetElim [foo_spec, bar_def, instBEqFloat]`, `mvcgen` will additionally\n\n* add a Hoare triple specification `foo_spec : ... → ⦃P⦄ foo ... ⦃Q⦄` to `spec` set for a\n  function `foo` occurring in `prog`,\n* unfold a definition `def bar_def ... := ...` in `prog`,\n* unfold any method of the `instBEqFloat : BEq Float` instance in `prog`.\n* it will no longer substitute away `let`-expressions that occur at most once in `P`, `Q` or `prog`.\n\nFurthermore, `mvcgen` tries to close trivial verification conditions by `SPred.entails.rfl` or\nthe tactic sequence `try (mpure_intro; trivial)`. The variant `mvcgen_no_trivial` does not do this.\n\nFor debugging purposes there is also `mvcgen_step 42` which will do at most 42 VC generation\nsteps. This is useful for bisecting issues with the generated VCs.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mvcgen\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">mvcgen</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/7c3ca70e29a0806bd4bfc62eae7084bbaf1a303d/src/Std/Tactic/Do/Syntax.lean#L211-L220","name":"Lean.Parser.Tactic.mspec","line":211,"kind":"def","docLink":"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mspec","doc":"`mspec` is an `apply`-like tactic that applies a Hoare triple specification to the target of the\nstateful goal.\n\nGiven a stateful goal `H ⊢ₛ wp⟦prog⟧.apply Q'`, `mspec foo_spec` will instantiate\n`foo_spec : ... → ⦃P⦄ foo ⦃Q⦄`, match `foo` against `prog` and produce subgoals for\nthe verification conditions `?pre : H ⊢ₛ P` and `?post : Q ⊢ₚ Q'`.\n\n* If `prog = x >>= f`, then `mspec Specs.bind` is tried first so that `foo` is matched against `x`\n  instead. Tactic `mspec_no_bind` does not attempt to do this decomposition.\n* If `?pre` or `?post` follow by `.rfl`, then they are discharged automatically.\n* `?post` is automatically simplified into constituent `⊢ₛ` entailments on\n  success and failure continuations.\n* `?pre` and `?post.*` goals introduce their stateful hypothesis as `h`.\n* Any uninstantiated MVar arising from instantiation of `foo_spec` becomes a new subgoal.\n* If the goal looks like `fun s => _ ⊢ₛ _` then `mspec` will first `mintro ∀s`.\n* If `P` has schematic variables that can be instantiated by doing `mintro ∀s`, for example\n  `foo_spec : ∀(n:Nat), ⦃⌜n = ‹Nat›ₛ⌝⦄ foo ⦃Q⦄`, then `mspec` will do `mintro ∀s` first to\n  instantiate `n = s`.\n* Right before applying the spec, the `mframe` tactic is used, which has the following effect:\n  Any hypothesis `Hᵢ` in the goal `h₁:H₁, h₂:H₂, ..., hₙ:Hₙ ⊢ₛ T` that is\n  pure (i.e., equivalent to some `⌜φᵢ⌝`) will be moved into the pure context as `hᵢ:φᵢ`.\n\nAdditionally, `mspec` can be used without arguments or with a term argument:\n\n* `mspec` without argument will try and look up a spec for `x` registered with `@[spec]`.\n* `mspec (foo_spec blah ?bleh)` will elaborate its argument as a term with expected type\n  `⦃?P⦄ x ⦃?Q⦄` and introduce `?bleh` as a subgoal.\n  This is useful to pass an invariant to e.g., `Specs.forIn_list` and leave the inductive step\n  as a hole.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mspec\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">mspec</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/7c3ca70e29a0806bd4bfc62eae7084bbaf1a303d/src/Std/Tactic/Do/Syntax.lean#L207-L208","name":"Lean.Parser.Tactic.mspecNoSimp","line":207,"kind":"def","docLink":"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mspecNoSimp","doc":"Like `mspec`, but does not attempt slight simplification and closing of trivial sub-goals.\n`mspec $spec` is roughly (the set of simp lemmas below might not be up to date)\n```\nmspec_no_simp $spec\nall_goals\n  ((try simp only [SPred.true_intro_simp, SPred.true_intro_simp_nil, SVal.curry_cons,\n                   SVal.uncurry_cons, SVal.getThe_here, SVal.getThe_there]);\n   (try mpure_intro; trivial))\n```\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mspecNoSimp\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">mspecNoSimp</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/7c3ca70e29a0806bd4bfc62eae7084bbaf1a303d/src/Std/Tactic/Do/Syntax.lean#L186-L194","name":"Lean.Parser.Tactic.mspecNoBind","line":186,"kind":"def","docLink":"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mspecNoBind","doc":"`mspec_no_simp $spec` first tries to decompose `Bind.bind`s before applying `$spec`.\nThis variant of `mspec_no_simp` does not; `mspec_no_bind $spec` is defined as\n```\ntry with_reducible mspec_no_bind Std.Do.Spec.bind\nmspec_no_bind $spec\n```\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mspecNoBind\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">mspecNoBind</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/7c3ca70e29a0806bd4bfc62eae7084bbaf1a303d/src/Std/Tactic/Do/Syntax.lean#L174-L175","name":"Lean.Parser.Tactic.mintro","line":174,"kind":"def","docLink":"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mintro","doc":"Like `intro`, but introducing stateful hypotheses into the stateful context of the `Std.Do.SPred`\nproof mode.\nThat is, given a stateful goal `(hᵢ : Hᵢ)* ⊢ₛ P → T`, `mintro h` transforms\ninto `(hᵢ : Hᵢ)*, (h : P) ⊢ₛ T`.\n\nFurthermore, `mintro ∀s` is like `intro s`, but preserves the stateful goal.\nThat is, `mintro ∀s` brings the topmost state variable `s:σ` in scope and transforms\n`(hᵢ : Hᵢ)* ⊢ₛ T` (where the entailment is in `Std.Do.SPred (σ::σs)`) into\n`(hᵢ : Hᵢ s)* ⊢ₛ T s` (where the entailment is in `Std.Do.SPred σs`).\n\nBeyond that, `mintro` supports the full syntax of `mcases` patterns\n(`mintro pat = (mintro h; mcases h with pat`), and can perform multiple\nintroductions in sequence.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mintro\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">mintro</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/7c3ca70e29a0806bd4bfc62eae7084bbaf1a303d/src/Std/Tactic/Do/Syntax.lean#L172-L172","name":"Lean.Parser.Tactic.«mintroPat∀_»","line":172,"kind":"def","docLink":"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.«mintroPat∀_»","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.«mintroPat∀_»\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">«mintroPat∀_»</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/7c3ca70e29a0806bd4bfc62eae7084bbaf1a303d/src/Std/Tactic/Do/Syntax.lean#L171-L171","name":"Lean.Parser.Tactic.mintroPat_","line":171,"kind":"def","docLink":"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mintroPat_","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mintroPat_\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">mintroPat_</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/7c3ca70e29a0806bd4bfc62eae7084bbaf1a303d/src/Std/Tactic/Do/Syntax.lean#L170-L170","name":"Lean.Parser.Tactic.mintroPat.quot","line":170,"kind":"def","docLink":"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mintroPat.quot","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mintroPat.quot\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">mintroPat</span>.<span class=\"name\">quot</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/7c3ca70e29a0806bd4bfc62eae7084bbaf1a303d/src/Std/Tactic/Do/Syntax.lean#L170-L170","name":"Lean.Parser.Category.mintroPat","line":170,"kind":"def","docLink":"./Std/Tactic/Do/Syntax.html#Lean.Parser.Category.mintroPat","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Do/Syntax.html#Lean.Parser.Category.mintroPat\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Category</span>.<span class=\"name\">mintroPat</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Notation.html#Lean.Parser.Category\">Category</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/7c3ca70e29a0806bd4bfc62eae7084bbaf1a303d/src/Std/Tactic/Do/Syntax.lean#L167-L168","name":"Lean.Parser.Tactic.mrefine","line":167,"kind":"def","docLink":"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mrefine","doc":"Like `refine`, but operating on stateful `Std.Do.SPred` goals.\n```lean\nexample (P Q R : SPred σs) : (P ∧ Q ∧ R) ⊢ₛ P ∧ R := by\n  mintro ⟨HP, HQ, HR⟩\n  mrefine ⟨HP, HR⟩\n\nexample (ψ : Nat → SPred σs) : ψ 42 ⊢ₛ ∃ x, ψ x := by\n  mintro H\n  mrefine ⟨⌜42⌝, H⟩\n```\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mrefine\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">mrefine</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/7c3ca70e29a0806bd4bfc62eae7084bbaf1a303d/src/Std/Tactic/Do/Syntax.lean#L158-L165","name":"Lean.Parser.Tactic.MRefinePat.parse.go","line":158,"kind":"opaque","docLink":"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.MRefinePat.parse.go","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.MRefinePat.parse.go\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">MRefinePat</span>.<span class=\"name\">parse</span>.<span class=\"name\">go</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Lean.TSyntax\">TSyntax</a> <span class=\"fn\">`mrefinePat</span> → <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.MRefinePat\">MRefinePat</a></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/7c3ca70e29a0806bd4bfc62eae7084bbaf1a303d/src/Std/Tactic/Do/Syntax.lean#L153-L165","name":"Lean.Parser.Tactic.MRefinePat.parse","line":153,"kind":"def","docLink":"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.MRefinePat.parse","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.MRefinePat.parse\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">MRefinePat</span>.<span class=\"name\">parse</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">pat</span> : <a href=\"./Init/Prelude.html#Lean.TSyntax\">TSyntax</a> <span class=\"fn\">`mrefinePat</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Lean.MacroM\">MacroM</a> <a href=\"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.MRefinePat\">MRefinePat</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/7c3ca70e29a0806bd4bfc62eae7084bbaf1a303d/src/Std/Tactic/Do/Syntax.lean#L151-L151","name":"Lean.Parser.Tactic.instInhabitedMRefinePat","line":151,"kind":"instance","docLink":"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.instInhabitedMRefinePat","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.instInhabitedMRefinePat\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">instInhabitedMRefinePat</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Inhabited\">Inhabited</a> <a href=\"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.MRefinePat\">MRefinePat</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/7c3ca70e29a0806bd4bfc62eae7084bbaf1a303d/src/Std/Tactic/Do/Syntax.lean#L151-L151","name":"Lean.Parser.Tactic.instReprMRefinePat","line":151,"kind":"instance","docLink":"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.instReprMRefinePat","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.instReprMRefinePat\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">instReprMRefinePat</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Data/Repr.html#Repr\">Repr</a> <a href=\"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.MRefinePat\">MRefinePat</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/7c3ca70e29a0806bd4bfc62eae7084bbaf1a303d/src/Std/Tactic/Do/Syntax.lean#L150-L150","name":"Lean.Parser.Tactic.MRefinePat.hole","line":150,"kind":"ctor","docLink":"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.MRefinePat.hole","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.MRefinePat.hole\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">MRefinePat</span>.<span class=\"name\">hole</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">name</span> : <a href=\"./Init/Prelude.html#Lean.TSyntax\">TSyntax</a> <span class=\"fn\">`Lean.binderIdent</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.MRefinePat\">MRefinePat</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/7c3ca70e29a0806bd4bfc62eae7084bbaf1a303d/src/Std/Tactic/Do/Syntax.lean#L149-L149","name":"Lean.Parser.Tactic.MRefinePat.stateful","line":149,"kind":"ctor","docLink":"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.MRefinePat.stateful","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.MRefinePat.stateful\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">MRefinePat</span>.<span class=\"name\">stateful</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h</span> : <a href=\"./Init/Prelude.html#Lean.TSyntax\">TSyntax</a> <span class=\"fn\">`Lean.binderIdent</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.MRefinePat\">MRefinePat</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/7c3ca70e29a0806bd4bfc62eae7084bbaf1a303d/src/Std/Tactic/Do/Syntax.lean#L148-L148","name":"Lean.Parser.Tactic.MRefinePat.pure","line":148,"kind":"ctor","docLink":"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.MRefinePat.pure","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.MRefinePat.pure\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">MRefinePat</span>.<span class=\"name\">pure</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h</span> : <a href=\"./Init/Prelude.html#Lean.TSyntax\">TSyntax</a> <span class=\"fn\">`term</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.MRefinePat\">MRefinePat</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/7c3ca70e29a0806bd4bfc62eae7084bbaf1a303d/src/Std/Tactic/Do/Syntax.lean#L147-L147","name":"Lean.Parser.Tactic.MRefinePat.tuple","line":147,"kind":"ctor","docLink":"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.MRefinePat.tuple","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.MRefinePat.tuple\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">MRefinePat</span>.<span class=\"name\">tuple</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">args</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.MRefinePat\">MRefinePat</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.MRefinePat\">MRefinePat</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/7c3ca70e29a0806bd4bfc62eae7084bbaf1a303d/src/Std/Tactic/Do/Syntax.lean#L146-L146","name":"Lean.Parser.Tactic.MRefinePat.one","line":146,"kind":"ctor","docLink":"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.MRefinePat.one","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.MRefinePat.one\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">MRefinePat</span>.<span class=\"name\">one</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">name</span> : <a href=\"./Init/Prelude.html#Lean.TSyntax\">TSyntax</a> <span class=\"fn\">`Lean.binderIdent</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.MRefinePat\">MRefinePat</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/7c3ca70e29a0806bd4bfc62eae7084bbaf1a303d/src/Std/Tactic/Do/Syntax.lean#L145-L151","name":"Lean.Parser.Tactic.MRefinePat","line":145,"kind":"inductive","docLink":"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.MRefinePat","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">inductive</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.MRefinePat\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">MRefinePat</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/7c3ca70e29a0806bd4bfc62eae7084bbaf1a303d/src/Std/Tactic/Do/Syntax.lean#L143-L143","name":"Lean.Parser.Tactic.«mrefinePat#_»","line":143,"kind":"def","docLink":"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.«mrefinePat#_»","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.«mrefinePat#_»\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">«mrefinePat#_»</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/7c3ca70e29a0806bd4bfc62eae7084bbaf1a303d/src/Std/Tactic/Do/Syntax.lean#L142-L142","name":"Lean.Parser.Tactic.«mrefinePat%_»","line":142,"kind":"def","docLink":"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.«mrefinePat%_»","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.«mrefinePat%_»\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">«mrefinePat%_»</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/7c3ca70e29a0806bd4bfc62eae7084bbaf1a303d/src/Std/Tactic/Do/Syntax.lean#L140-L140","name":"Lean.Parser.Tactic.mrefinePat?_","line":140,"kind":"def","docLink":"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mrefinePat?_","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mrefinePat?_\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">mrefinePat?_</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/7c3ca70e29a0806bd4bfc62eae7084bbaf1a303d/src/Std/Tactic/Do/Syntax.lean#L139-L139","name":"Lean.Parser.Tactic.«mrefinePat□_»","line":139,"kind":"def","docLink":"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.«mrefinePat□_»","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.«mrefinePat□_»\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">«mrefinePat□_»</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/7c3ca70e29a0806bd4bfc62eae7084bbaf1a303d/src/Std/Tactic/Do/Syntax.lean#L138-L138","name":"Lean.Parser.Tactic.«mrefinePat⌜_⌝»","line":138,"kind":"def","docLink":"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.«mrefinePat⌜_⌝»","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.«mrefinePat⌜_⌝»\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">«mrefinePat⌜_⌝»</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/7c3ca70e29a0806bd4bfc62eae7084bbaf1a303d/src/Std/Tactic/Do/Syntax.lean#L137-L137","name":"Lean.Parser.Tactic.«mrefinePat(_)»","line":137,"kind":"def","docLink":"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.«mrefinePat(_)»","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.«mrefinePat(_)»\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">«mrefinePat(_)»</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/7c3ca70e29a0806bd4bfc62eae7084bbaf1a303d/src/Std/Tactic/Do/Syntax.lean#L136-L136","name":"Lean.Parser.Tactic.«mrefinePat⟨_⟩»","line":136,"kind":"def","docLink":"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.«mrefinePat⟨_⟩»","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.«mrefinePat⟨_⟩»\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">«mrefinePat⟨_⟩»</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/7c3ca70e29a0806bd4bfc62eae7084bbaf1a303d/src/Std/Tactic/Do/Syntax.lean#L135-L135","name":"Lean.Parser.Tactic.mrefinePats","line":135,"kind":"def","docLink":"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mrefinePats","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mrefinePats\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">mrefinePats</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/7c3ca70e29a0806bd4bfc62eae7084bbaf1a303d/src/Std/Tactic/Do/Syntax.lean#L134-L134","name":"Lean.Parser.Tactic.mrefinePat_","line":134,"kind":"def","docLink":"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mrefinePat_","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mrefinePat_\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">mrefinePat_</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/7c3ca70e29a0806bd4bfc62eae7084bbaf1a303d/src/Std/Tactic/Do/Syntax.lean#L133-L133","name":"Lean.Parser.Tactic.mrefinePat.quot","line":133,"kind":"def","docLink":"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mrefinePat.quot","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mrefinePat.quot\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">mrefinePat</span>.<span class=\"name\">quot</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/7c3ca70e29a0806bd4bfc62eae7084bbaf1a303d/src/Std/Tactic/Do/Syntax.lean#L133-L133","name":"Lean.Parser.Category.mrefinePat","line":133,"kind":"def","docLink":"./Std/Tactic/Do/Syntax.html#Lean.Parser.Category.mrefinePat","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Do/Syntax.html#Lean.Parser.Category.mrefinePat\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Category</span>.<span class=\"name\">mrefinePat</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Notation.html#Lean.Parser.Category\">Category</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/7c3ca70e29a0806bd4bfc62eae7084bbaf1a303d/src/Std/Tactic/Do/Syntax.lean#L130-L131","name":"Lean.Parser.Tactic.mcases","line":130,"kind":"def","docLink":"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mcases","doc":"Like `rcases`, but operating on stateful `Std.Do.SPred` goals.\nExample: Given a goal `h : (P ∧ (Q ∨ R) ∧ (Q → R)) ⊢ₛ R`,\n`mcases h with ⟨-, ⟨hq | hr⟩, hqr⟩` will yield two goals:\n`(hq : Q, hqr : Q → R) ⊢ₛ R` and `(hr : R) ⊢ₛ R`.\n\nThat is, `mcases h with pat` has the following semantics, based on `pat`:\n* `pat=□h'` renames `h` to `h'` in the stateful context, regardless of whether `h` is pure\n* `pat=⌜h'⌝` introduces `h' : φ`  to the pure local context if `h : ⌜φ⌝`\n  (c.f. `Lean.Elab.Tactic.Do.ProofMode.IsPure`)\n* `pat=h'` is like `pat=⌜h'⌝` if `h` is pure\n  (c.f. `Lean.Elab.Tactic.Do.ProofMode.IsPure`), otherwise it is like `pat=□h'`.\n* `pat=_` renames `h` to an inaccessible name\n* `pat=-` discards `h`\n* `⟨pat₁, pat₂⟩` matches on conjunctions and existential quantifiers and recurses via\n  `pat₁` and `pat₂`.\n* `⟨pat₁ | pat₂⟩` matches on disjunctions, matching the left alternative via `pat₁` and the right\n  alternative via `pat₂`.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mcases\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">mcases</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/7c3ca70e29a0806bd4bfc62eae7084bbaf1a303d/src/Std/Tactic/Do/Syntax.lean#L123-L128","name":"Lean.Parser.Tactic.MCasesPat.parse.goAlts","line":123,"kind":"opaque","docLink":"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.MCasesPat.parse.goAlts","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.MCasesPat.parse.goAlts\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">MCasesPat</span>.<span class=\"name\">parse</span>.<span class=\"name\">goAlts</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Lean.TSyntax\">TSyntax</a> <span class=\"fn\">`Lean.Parser.Tactic.mcasesPatAlts</span> → <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.MCasesPat\">MCasesPat</a></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/7c3ca70e29a0806bd4bfc62eae7084bbaf1a303d/src/Std/Tactic/Do/Syntax.lean#L115-L122","name":"Lean.Parser.Tactic.MCasesPat.parse.go","line":115,"kind":"opaque","docLink":"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.MCasesPat.parse.go","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.MCasesPat.parse.go\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">MCasesPat</span>.<span class=\"name\">parse</span>.<span class=\"name\">go</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Lean.TSyntax\">TSyntax</a> <span class=\"fn\">`mcasesPat</span> → <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.MCasesPat\">MCasesPat</a></span></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/7c3ca70e29a0806bd4bfc62eae7084bbaf1a303d/src/Std/Tactic/Do/Syntax.lean#L110-L128","name":"Lean.Parser.Tactic.MCasesPat.parse","line":110,"kind":"def","docLink":"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.MCasesPat.parse","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.MCasesPat.parse\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">MCasesPat</span>.<span class=\"name\">parse</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">pat</span> : <a href=\"./Init/Prelude.html#Lean.TSyntax\">TSyntax</a> <span class=\"fn\">`mcasesPat</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Lean.MacroM\">MacroM</a> <a href=\"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.MCasesPat\">MCasesPat</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/7c3ca70e29a0806bd4bfc62eae7084bbaf1a303d/src/Std/Tactic/Do/Syntax.lean#L108-L108","name":"Lean.Parser.Tactic.instInhabitedMCasesPat","line":108,"kind":"instance","docLink":"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.instInhabitedMCasesPat","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.instInhabitedMCasesPat\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">instInhabitedMCasesPat</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Inhabited\">Inhabited</a> <a href=\"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.MCasesPat\">MCasesPat</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/7c3ca70e29a0806bd4bfc62eae7084bbaf1a303d/src/Std/Tactic/Do/Syntax.lean#L108-L108","name":"Lean.Parser.Tactic.instReprMCasesPat","line":108,"kind":"instance","docLink":"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.instReprMCasesPat","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.instReprMCasesPat\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">instReprMCasesPat</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Data/Repr.html#Repr\">Repr</a> <a href=\"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.MCasesPat\">MCasesPat</a></span></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/7c3ca70e29a0806bd4bfc62eae7084bbaf1a303d/src/Std/Tactic/Do/Syntax.lean#L107-L107","name":"Lean.Parser.Tactic.MCasesPat.stateful","line":107,"kind":"ctor","docLink":"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.MCasesPat.stateful","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.MCasesPat.stateful\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">MCasesPat</span>.<span class=\"name\">stateful</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h</span> : <a href=\"./Init/Prelude.html#Lean.TSyntax\">TSyntax</a> <span class=\"fn\">`Lean.binderIdent</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.MCasesPat\">MCasesPat</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/7c3ca70e29a0806bd4bfc62eae7084bbaf1a303d/src/Std/Tactic/Do/Syntax.lean#L106-L106","name":"Lean.Parser.Tactic.MCasesPat.pure","line":106,"kind":"ctor","docLink":"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.MCasesPat.pure","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.MCasesPat.pure\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">MCasesPat</span>.<span class=\"name\">pure</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h</span> : <a href=\"./Init/Prelude.html#Lean.TSyntax\">TSyntax</a> <span class=\"fn\">`Lean.binderIdent</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.MCasesPat\">MCasesPat</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/7c3ca70e29a0806bd4bfc62eae7084bbaf1a303d/src/Std/Tactic/Do/Syntax.lean#L105-L105","name":"Lean.Parser.Tactic.MCasesPat.alts","line":105,"kind":"ctor","docLink":"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.MCasesPat.alts","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.MCasesPat.alts\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">MCasesPat</span>.<span class=\"name\">alts</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">args</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.MCasesPat\">MCasesPat</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.MCasesPat\">MCasesPat</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/7c3ca70e29a0806bd4bfc62eae7084bbaf1a303d/src/Std/Tactic/Do/Syntax.lean#L104-L104","name":"Lean.Parser.Tactic.MCasesPat.tuple","line":104,"kind":"ctor","docLink":"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.MCasesPat.tuple","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.MCasesPat.tuple\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">MCasesPat</span>.<span class=\"name\">tuple</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">args</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.MCasesPat\">MCasesPat</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.MCasesPat\">MCasesPat</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/7c3ca70e29a0806bd4bfc62eae7084bbaf1a303d/src/Std/Tactic/Do/Syntax.lean#L103-L103","name":"Lean.Parser.Tactic.MCasesPat.clear","line":103,"kind":"ctor","docLink":"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.MCasesPat.clear","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.MCasesPat.clear\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">MCasesPat</span>.<span class=\"name\">clear</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.MCasesPat\">MCasesPat</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/7c3ca70e29a0806bd4bfc62eae7084bbaf1a303d/src/Std/Tactic/Do/Syntax.lean#L102-L102","name":"Lean.Parser.Tactic.MCasesPat.one","line":102,"kind":"ctor","docLink":"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.MCasesPat.one","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.MCasesPat.one\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">MCasesPat</span>.<span class=\"name\">one</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">name</span> : <a href=\"./Init/Prelude.html#Lean.TSyntax\">TSyntax</a> <span class=\"fn\">`Lean.binderIdent</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.MCasesPat\">MCasesPat</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/7c3ca70e29a0806bd4bfc62eae7084bbaf1a303d/src/Std/Tactic/Do/Syntax.lean#L101-L108","name":"Lean.Parser.Tactic.MCasesPat","line":101,"kind":"inductive","docLink":"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.MCasesPat","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">inductive</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.MCasesPat\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">MCasesPat</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/7c3ca70e29a0806bd4bfc62eae7084bbaf1a303d/src/Std/Tactic/Do/Syntax.lean#L99-L99","name":"Lean.Parser.Tactic.«mcasesPat#_»","line":99,"kind":"def","docLink":"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.«mcasesPat#_»","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.«mcasesPat#_»\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">«mcasesPat#_»</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/7c3ca70e29a0806bd4bfc62eae7084bbaf1a303d/src/Std/Tactic/Do/Syntax.lean#L98-L98","name":"Lean.Parser.Tactic.«mcasesPat%_»","line":98,"kind":"def","docLink":"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.«mcasesPat%_»","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.«mcasesPat%_»\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">«mcasesPat%_»</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/7c3ca70e29a0806bd4bfc62eae7084bbaf1a303d/src/Std/Tactic/Do/Syntax.lean#L96-L96","name":"Lean.Parser.Tactic.«mcasesPat□_»","line":96,"kind":"def","docLink":"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.«mcasesPat□_»","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.«mcasesPat□_»\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">«mcasesPat□_»</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/7c3ca70e29a0806bd4bfc62eae7084bbaf1a303d/src/Std/Tactic/Do/Syntax.lean#L95-L95","name":"Lean.Parser.Tactic.«mcasesPat⌜_⌝»","line":95,"kind":"def","docLink":"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.«mcasesPat⌜_⌝»","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.«mcasesPat⌜_⌝»\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">«mcasesPat⌜_⌝»</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/7c3ca70e29a0806bd4bfc62eae7084bbaf1a303d/src/Std/Tactic/Do/Syntax.lean#L94-L94","name":"Lean.Parser.Tactic.«mcasesPat(_)»","line":94,"kind":"def","docLink":"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.«mcasesPat(_)»","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.«mcasesPat(_)»\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">«mcasesPat(_)»</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/7c3ca70e29a0806bd4bfc62eae7084bbaf1a303d/src/Std/Tactic/Do/Syntax.lean#L93-L93","name":"Lean.Parser.Tactic.«mcasesPat⟨_⟩»","line":93,"kind":"def","docLink":"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.«mcasesPat⟨_⟩»","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.«mcasesPat⟨_⟩»\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">«mcasesPat⟨_⟩»</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/7c3ca70e29a0806bd4bfc62eae7084bbaf1a303d/src/Std/Tactic/Do/Syntax.lean#L92-L92","name":"Lean.Parser.Tactic.«mcasesPat-»","line":92,"kind":"def","docLink":"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.«mcasesPat-»","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.«mcasesPat-»\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">«mcasesPat-»</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/7c3ca70e29a0806bd4bfc62eae7084bbaf1a303d/src/Std/Tactic/Do/Syntax.lean#L91-L91","name":"Lean.Parser.Tactic.mcasesPat_","line":91,"kind":"def","docLink":"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mcasesPat_","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mcasesPat_\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">mcasesPat_</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/7c3ca70e29a0806bd4bfc62eae7084bbaf1a303d/src/Std/Tactic/Do/Syntax.lean#L90-L90","name":"Lean.Parser.Tactic.mcasesPatAlts","line":90,"kind":"def","docLink":"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mcasesPatAlts","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mcasesPatAlts\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">mcasesPatAlts</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/7c3ca70e29a0806bd4bfc62eae7084bbaf1a303d/src/Std/Tactic/Do/Syntax.lean#L89-L89","name":"Lean.Parser.Category.mcasesPat","line":89,"kind":"def","docLink":"./Std/Tactic/Do/Syntax.html#Lean.Parser.Category.mcasesPat","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Do/Syntax.html#Lean.Parser.Category.mcasesPat\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Category</span>.<span class=\"name\">mcasesPat</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Notation.html#Lean.Parser.Category\">Category</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/7c3ca70e29a0806bd4bfc62eae7084bbaf1a303d/src/Std/Tactic/Do/Syntax.lean#L89-L89","name":"Lean.Parser.Tactic.mcasesPat.quot","line":89,"kind":"def","docLink":"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mcasesPat.quot","doc":""},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mcasesPat.quot\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">mcasesPat</span>.<span class=\"name\">quot</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/7c3ca70e29a0806bd4bfc62eae7084bbaf1a303d/src/Std/Tactic/Do/Syntax.lean#L86-L87","name":"Lean.Parser.Tactic.mstop","line":86,"kind":"def","docLink":"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mstop","doc":"Stops the stateful proof mode of `Std.Do.SPred`.\nThis will simply forget all the names given to stateful hypotheses and pretty-print\na bit differently.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mstop\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">mstop</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/7c3ca70e29a0806bd4bfc62eae7084bbaf1a303d/src/Std/Tactic/Do/Syntax.lean#L83-L84","name":"Lean.Parser.Tactic.mstart","line":83,"kind":"def","docLink":"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mstart","doc":"Start the stateful proof mode of `Std.Do.SPred`.\nThis will transform a stateful goal of the form `H ⊢ₛ T` into `⊢ₛ H → T`\nupon which `mintro` can be used to re-introduce `H` and give it a name.\nIt is often more convenient to use `mintro` directly, which will\ntry `mstart` automatically if necessary.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mstart\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">mstart</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/7c3ca70e29a0806bd4bfc62eae7084bbaf1a303d/src/Std/Tactic/Do/Syntax.lean#L80-L81","name":"Lean.Parser.Tactic.mspecializePure","line":80,"kind":"def","docLink":"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mspecializePure","doc":"`mspecialize_pure` is like `mspecialize`, but it specializes a hypothesis from the\n*pure* context with hypotheses from either the pure or stateful context or pure terms.\n```lean\nexample (y : Nat) (P Q : SPred σs) (Ψ : Nat → SPred σs) (hP : ⊢ₛ P) (hΨ : ∀ x, ⊢ₛ P → Q → Ψ x) : ⊢ₛ Q → Ψ (y + 1) := by\n  mintro HQ\n  mspecialize_pure (hΨ (y + 1)) hP HQ => HΨ\n  mexact HΨ\n```\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mspecializePure\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">mspecializePure</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/7c3ca70e29a0806bd4bfc62eae7084bbaf1a303d/src/Std/Tactic/Do/Syntax.lean#L77-L78","name":"Lean.Parser.Tactic.mspecialize","line":77,"kind":"def","docLink":"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mspecialize","doc":"`mspecialize` is like `specialize`, but operating on a stateful `Std.Do.SPred` goal.\nIt specializes a hypothesis from the stateful context with hypotheses from either the pure\nor stateful context or pure terms.\n```lean\nexample (P Q : SPred σs) : P ⊢ₛ (P → Q) → Q := by\n  mintro HP HPQ\n  mspecialize HPQ HP\n  mexact HPQ\n\nexample (y : Nat) (P Q : SPred σs) (Ψ : Nat → SPred σs) (hP : ⊢ₛ P) : ⊢ₛ Q → (∀ x, P → Q → Ψ x) → Ψ (y + 1) := by\n  mintro HQ HΨ\n  mspecialize HΨ (y + 1) hP HQ\n  mexact HΨ\n```\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mspecialize\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">mspecialize</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/7c3ca70e29a0806bd4bfc62eae7084bbaf1a303d/src/Std/Tactic/Do/Syntax.lean#L74-L75","name":"Lean.Parser.Tactic.mrevert","line":74,"kind":"def","docLink":"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mrevert","doc":"`mrevert` is like `revert`, but operating on a stateful `Std.Do.SPred` goal.\n```lean\nexample (P Q R : SPred σs) : P ∧ Q ∧ R ⊢ₛ P → R := by\n  mintro ⟨HP, HQ, HR⟩\n  mrevert HR\n  mrevert HP\n  mintro HP'\n  mintro HR'\n  mexact HR'\n```\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mrevert\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">mrevert</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/7c3ca70e29a0806bd4bfc62eae7084bbaf1a303d/src/Std/Tactic/Do/Syntax.lean#L71-L72","name":"Lean.Parser.Tactic.mpureIntro","line":71,"kind":"def","docLink":"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mpureIntro","doc":"`mpure_intro` operates on a stateful `Std.Do.SPred` goal of the form `P ⊢ₛ ⌜φ⌝`.\nIt leaves the stateful proof mode (thereby discarding `P`), leaving the regular goal `φ`.\n```lean\ntheorem simple : ⊢ₛ (⌜True⌝ : SPred σs) := by\n  mpure_intro\n  exact True.intro\n```\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mpureIntro\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">mpureIntro</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/7c3ca70e29a0806bd4bfc62eae7084bbaf1a303d/src/Std/Tactic/Do/Syntax.lean#L67-L68","name":"Lean.Parser.Tactic.mpure","line":67,"kind":"def","docLink":"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mpure","doc":"`mpure` moves a pure hypothesis from the stateful context into the pure context.\n```lean\nexample (Q : SPred σs) (ψ : φ → ⊢ₛ Q): ⌜φ⌝ ⊢ₛ Q := by\n  mintro Hφ\n  mpure Hφ\n  mexact (ψ Hφ)\n```\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mpure\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">mpure</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/7c3ca70e29a0806bd4bfc62eae7084bbaf1a303d/src/Std/Tactic/Do/Syntax.lean#L64-L65","name":"Lean.Parser.Tactic.mleft","line":64,"kind":"def","docLink":"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mleft","doc":"`mleft` is like `left`, but operating on a stateful `Std.Do.SPred` goal.\n```lean\nexample (P Q : SPred σs) : P ⊢ₛ P ∨ Q := by\n  mintro HP\n  mleft\n  mexact HP\n```\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mleft\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">mleft</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/7c3ca70e29a0806bd4bfc62eae7084bbaf1a303d/src/Std/Tactic/Do/Syntax.lean#L61-L62","name":"Lean.Parser.Tactic.mright","line":61,"kind":"def","docLink":"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mright","doc":"`mright` is like `right`, but operating on a stateful `Std.Do.SPred` goal.\n```lean\nexample (P Q : SPred σs) : P ⊢ₛ Q ∨ P := by\n  mintro HP\n  mright\n  mexact HP\n```\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mright\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">mright</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/7c3ca70e29a0806bd4bfc62eae7084bbaf1a303d/src/Std/Tactic/Do/Syntax.lean#L58-L59","name":"Lean.Parser.Tactic.mreplace","line":58,"kind":"def","docLink":"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mreplace","doc":"`mreplace` is like `replace`, but operating on a stateful `Std.Do.SPred` goal.\n```lean\nexample (P Q : SPred σs) : P ⊢ₛ (P → Q) → Q := by\n  mintro HP HPQ\n  mreplace HPQ : Q := by mspecialize HPQ HP; mexact HPQ\n  mexact HPQ\n```\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mreplace\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">mreplace</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/7c3ca70e29a0806bd4bfc62eae7084bbaf1a303d/src/Std/Tactic/Do/Syntax.lean#L55-L56","name":"Lean.Parser.Tactic.mhave","line":55,"kind":"def","docLink":"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mhave","doc":"`mhave` is like `have`, but operating on a stateful `Std.Do.SPred` goal.\n```lean\nexample (P Q : SPred σs) : P ⊢ₛ (P → Q) → Q := by\n  mintro HP HPQ\n  mhave HQ : Q := by mspecialize HPQ HP; mexact HPQ\n  mexact HQ\n```\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mhave\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">mhave</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/7c3ca70e29a0806bd4bfc62eae7084bbaf1a303d/src/Std/Tactic/Do/Syntax.lean#L52-L53","name":"Lean.Parser.Tactic.mdup","line":52,"kind":"def","docLink":"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mdup","doc":"Duplicate a stateful `Std.Do.SPred` hypothesis. "},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mdup\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">mdup</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/7c3ca70e29a0806bd4bfc62eae7084bbaf1a303d/src/Std/Tactic/Do/Syntax.lean#L49-L50","name":"Lean.Parser.Tactic.mframe","line":49,"kind":"def","docLink":"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mframe","doc":"`mframe` infers which hypotheses from the stateful context can be moved into the pure context.\nThis is useful because pure hypotheses \"survive\" the next application of modus ponens\n(`Std.Do.SPred.mp`) and transitivity (`Std.Do.SPred.entails.trans`).\n\nIt is used as part of the `mspec` tactic.\n\n```lean\nexample (P Q : SPred σs) : ⊢ₛ ⌜p⌝ ∧ Q ∧ ⌜q⌝ ∧ ⌜r⌝ ∧ P ∧ ⌜s⌝ ∧ ⌜t⌝ → Q := by\n  mintro _\n  mframe\n  /- `h : p ∧ q ∧ r ∧ s ∧ t` in the pure context -/\n  mcases h with hP\n  mexact h\n```\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mframe\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">mframe</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/7c3ca70e29a0806bd4bfc62eae7084bbaf1a303d/src/Std/Tactic/Do/Syntax.lean#L46-L47","name":"Lean.Parser.Tactic.mexists","line":46,"kind":"def","docLink":"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mexists","doc":"`mexists` is like `exists`, but operating on a stateful `Std.Do.SPred` goal.\n```lean\nexample (ψ : Nat → SPred σs) : ψ 42 ⊢ₛ ∃ x, ψ x := by\n  mintro H\n  mexists 42\n```\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mexists\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">mexists</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/7c3ca70e29a0806bd4bfc62eae7084bbaf1a303d/src/Std/Tactic/Do/Syntax.lean#L43-L44","name":"Lean.Parser.Tactic.mexfalso","line":43,"kind":"def","docLink":"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mexfalso","doc":"`mexfalso` is like `exfalso`, but operating on a stateful `Std.Do.SPred` goal.\n```lean\nexample (P : SPred σs) : ⌜False⌝ ⊢ₛ P := by\n  mintro HP\n  mexfalso\n  mexact HP\n```\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mexfalso\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">mexfalso</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/7c3ca70e29a0806bd4bfc62eae7084bbaf1a303d/src/Std/Tactic/Do/Syntax.lean#L40-L41","name":"Lean.Parser.Tactic.mexact","line":40,"kind":"def","docLink":"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mexact","doc":"`mexact` is like `exact`, but operating on a stateful `Std.Do.SPred` goal.\n```lean\nexample (Q : SPred σs) : Q ⊢ₛ Q := by\n  mstart\n  mintro HQ\n  mexact HQ\n```\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mexact\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">mexact</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/7c3ca70e29a0806bd4bfc62eae7084bbaf1a303d/src/Std/Tactic/Do/Syntax.lean#L37-L38","name":"Lean.Parser.Tactic.mconstructor","line":37,"kind":"def","docLink":"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mconstructor","doc":"`mconstructor` is like `constructor`, but operating on a stateful `Std.Do.SPred` goal.\n```lean\nexample (Q : SPred σs) : Q ⊢ₛ Q ∧ Q := by\n  mintro HQ\n  mconstructor <;> mexact HQ\n```\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mconstructor\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">mconstructor</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/7c3ca70e29a0806bd4bfc62eae7084bbaf1a303d/src/Std/Tactic/Do/Syntax.lean#L34-L35","name":"Lean.Parser.Tactic.mclear","line":34,"kind":"def","docLink":"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mclear","doc":"`mclear` is like `clear`, but operating on a stateful `Std.Do.SPred` goal.\n```lean\nexample (P Q : SPred σs) : P ⊢ₛ Q → Q := by\n  mintro HP\n  mintro HQ\n  mclear HP\n  mexact HQ\n```\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mclear\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">mclear</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/7c3ca70e29a0806bd4bfc62eae7084bbaf1a303d/src/Std/Tactic/Do/Syntax.lean#L31-L32","name":"Lean.Parser.Tactic.massumption","line":31,"kind":"def","docLink":"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.massumption","doc":"`massumption` is like `assumption`, but operating on a stateful `Std.Do.SPred` goal.\n```lean\nexample (P Q : SPred σs) : Q ⊢ₛ P → Q := by\n  mintro _ _\n  massumption\n```\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.massumption\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">massumption</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>"},{"info":{"sourceLink":"https://github.com/leanprover/lean4/blob/7c3ca70e29a0806bd4bfc62eae7084bbaf1a303d/src/Std/Tactic/Do/Syntax.lean#L16-L25","name":"Lean.Parser.Attr.spec","line":16,"kind":"def","docLink":"./Std/Tactic/Do/Syntax.html#Lean.Parser.Attr.spec","doc":"Theorems tagged with the `spec` attribute are used by the `mspec` and `mvcgen` tactics.\n\n* When used on a theorem `foo_spec : Triple (foo a b c) P Q`, then `mspec` and `mvcgen` will use\n  `foo_spec` as a specification for calls to `foo`.\n* Otherwise, when used on a definition that `@[simp]` would work on, it is added to the internal\n  simp set of `mvcgen` that is used within `wp⟦·⟧` contexts to simplify match discriminants and\n  applications of constants.\n"},"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Std/Tactic/Do/Syntax.html#Lean.Parser.Attr.spec\"><span class=\"name\">Lean</span>.<span class=\"name\">Parser</span>.<span class=\"name\">Attr</span>.<span class=\"name\">spec</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>"}]}