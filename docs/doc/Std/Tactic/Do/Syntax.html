<html lang="en"><head><meta charset="UTF-8"></meta><meta name="viewport" content="width=device-width, initial-scale=1"></meta><link rel="stylesheet" href="../../.././style.css"></link><link rel="icon" href="../../.././favicon.svg"></link><link rel="mask-icon" href="../../.././favicon.svg" color="#000000"></link><link rel="prefetch" href="../../.././/declarations/declaration-data.bmp" as="image"></link><title>Std.Tactic.Do.Syntax</title><script defer="true" src="../../.././mathjax-config.js"></script><script defer="true" src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script><script defer="true" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><script>const SITE_ROOT="../../.././";</script><script>const MODULE_NAME="Std.Tactic.Do.Syntax";</script><script type="module" src="../../.././jump-src.js"></script><script type="module" src="../../.././search.js"></script><script type="module" src="../../.././expand-nav.js"></script><script type="module" src="../../.././how-about.js"></script><script type="module" src="../../.././instances.js"></script><script type="module" src="../../.././importedBy.js"></script></head><body><input id="nav_toggle" type="checkbox"></input><header><h1><label for="nav_toggle"></label><span>Documentation</span></h1><h2 class="header_filename break_within"><span class="name">Std</span>.<span class="name">Tactic</span>.<span class="name">Do</span>.<span class="name">Syntax</span></h2><form id="search_form"><input type="text" name="q" autocomplete="off"></input>&#32;<button id="search_button" onclick="javascript: form.action='../../.././search.html';">Search</button></form></header><nav class="internal_nav"><p><a href="#top">return to top</a></p><p class="gh_nav_link"><a href="https://github.com/leanprover/lean4/blob/7c3ca70e29a0806bd4bfc62eae7084bbaf1a303d/src/Std/Tactic/Do/Syntax.lean">source</a></p><div class="imports"><details><summary>Imports</summary><ul><li><a href="../../.././Init/NotationExtra.html">Init.NotationExtra</a></li><li><a href="../../.././Std/Do.html">Std.Do</a></li><li><a href="../../.././Std/Tactic/Do/ProofMode.html">Std.Tactic.Do.ProofMode</a></li></ul></details><details><summary>Imported by</summary><ul id="imported-by-Std.Tactic.Do.Syntax" class="imported-by-list"></ul></details></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Attr.spec"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Attr</span>.<span class="name">spec</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.massumption"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">massumption</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.mclear"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">mclear</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.mconstructor"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">mconstructor</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.mexact"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">mexact</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.mexfalso"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">mexfalso</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.mexists"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">mexists</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.mframe"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">mframe</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.mdup"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">mdup</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.mhave"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">mhave</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.mreplace"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">mreplace</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.mright"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">mright</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.mleft"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">mleft</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.mpure"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">mpure</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.mpureIntro"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">mpureIntro</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.mrevert"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">mrevert</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.mspecialize"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">mspecialize</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.mspecializePure"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">mspecializePure</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.mstart"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">mstart</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.mstop"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">mstop</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.mcasesPat.quot"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">mcasesPat</span>.<span class="name">quot</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Category.mcasesPat"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Category</span>.<span class="name">mcasesPat</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.mcasesPatAlts"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">mcasesPatAlts</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.mcasesPat_"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">mcasesPat_</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.«mcasesPat-»"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">«mcasesPat-»</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.«mcasesPat⟨_⟩»"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">«mcasesPat⟨_⟩»</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.«mcasesPat(_)»"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">«mcasesPat(_)»</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.«mcasesPat⌜_⌝»"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">«mcasesPat⌜_⌝»</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.«mcasesPat□_»"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">«mcasesPat□_»</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.«mcasesPat%_»"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">«mcasesPat%_»</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.«mcasesPat#_»"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">«mcasesPat#_»</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.MCasesPat"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">MCasesPat</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.instReprMCasesPat"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">instReprMCasesPat</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.instInhabitedMCasesPat"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">instInhabitedMCasesPat</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.MCasesPat.parse"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">MCasesPat</span>.<span class="name">parse</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.MCasesPat.parse.go"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">MCasesPat</span>.<span class="name">parse</span>.<span class="name">go</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.MCasesPat.parse.goAlts"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">MCasesPat</span>.<span class="name">parse</span>.<span class="name">goAlts</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.mcases"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">mcases</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Category.mrefinePat"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Category</span>.<span class="name">mrefinePat</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.mrefinePat.quot"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">mrefinePat</span>.<span class="name">quot</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.mrefinePat_"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">mrefinePat_</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.mrefinePats"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">mrefinePats</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.«mrefinePat⟨_⟩»"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">«mrefinePat⟨_⟩»</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.«mrefinePat(_)»"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">«mrefinePat(_)»</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.«mrefinePat⌜_⌝»"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">«mrefinePat⌜_⌝»</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.«mrefinePat□_»"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">«mrefinePat□_»</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.mrefinePat?_"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">mrefinePat?_</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.«mrefinePat%_»"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">«mrefinePat%_»</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.«mrefinePat#_»"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">«mrefinePat#_»</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.MRefinePat"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">MRefinePat</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.instReprMRefinePat"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">instReprMRefinePat</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.instInhabitedMRefinePat"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">instInhabitedMRefinePat</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.MRefinePat.parse"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">MRefinePat</span>.<span class="name">parse</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.MRefinePat.parse.go"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">MRefinePat</span>.<span class="name">parse</span>.<span class="name">go</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.mrefine"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">mrefine</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Category.mintroPat"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Category</span>.<span class="name">mintroPat</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.mintroPat.quot"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">mintroPat</span>.<span class="name">quot</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.mintroPat_"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">mintroPat_</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.«mintroPat∀_»"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">«mintroPat∀_»</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.mintro"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">mintro</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.mspecNoBind"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">mspecNoBind</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.mspecNoSimp"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">mspecNoSimp</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.mspec"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">mspec</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.mvcgen"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">mvcgen</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.mvcgenNoTrivial"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">mvcgenNoTrivial</span></a></div><div class="nav_link"><a class="break_within" href="#Lean.Parser.Tactic.mvcgenStep"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">mvcgenStep</span></a></div></nav><main>
<div class="decl" id="Lean.Parser.Attr.spec"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/7c3ca70e29a0806bd4bfc62eae7084bbaf1a303d/src/Std/Tactic/Do/Syntax.lean#L16-L25">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Attr.spec"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Attr</span>.<span class="name">spec</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a></div></div><p>Theorems tagged with the <code><a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Attr.spec">spec</a></code> attribute are used by the <code><a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mspec">mspec</a></code> and <code><a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mvcgen">mvcgen</a></code> tactics.</p><ul>
<li>When used on a theorem <code>foo_spec : Triple (foo a b c) P Q</code>, then <code><a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mspec">mspec</a></code> and <code><a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mvcgen">mvcgen</a></code> will use
<code>foo_spec</code> as a specification for calls to <code>foo</code>.</li>
<li>Otherwise, when used on a definition that <code>@[simp]</code> would work on, it is added to the internal
simp set of <code><a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mvcgen">mvcgen</a></code> that is used within <code>wp⟦·⟧</code> contexts to simplify match discriminants and
applications of constants.</li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Attr.spec" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.massumption"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/7c3ca70e29a0806bd4bfc62eae7084bbaf1a303d/src/Std/Tactic/Do/Syntax.lean#L31-L32">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.massumption"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">massumption</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a></div></div><p><code><a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.massumption">massumption</a></code> is like <code>assumption</code>, but operating on a stateful <code><a href="../../.././Std/Do/SPred/SPred.html#Std.Do.SPred">Std.Do.SPred</a></code> goal.</p><pre><code class="language-lean">example (P Q : SPred σs) : Q ⊢ₛ P → Q := by
  <a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mintro">mintro</a> _ _
  <a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.massumption">massumption</a>
</code></pre><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.massumption">Lean.Parser.Tactic.massumption</a> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../.././Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`Lean.Parser.Tactic.massumption</span> <span class="fn">1024</span> <span class="fn">(<a href="../../.././Init/Prelude.html#Lean.ParserDescr.nonReservedSymbol">Lean.ParserDescr.nonReservedSymbol</a> <span class="fn">&quot;massumption&quot;</span> <a href="../../.././Init/Prelude.html#Bool.false">false</a>)</span></span></li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.massumption" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.mclear"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/7c3ca70e29a0806bd4bfc62eae7084bbaf1a303d/src/Std/Tactic/Do/Syntax.lean#L34-L35">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mclear"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">mclear</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a></div></div><p><code><a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mclear">mclear</a></code> is like <code><a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.MCasesPat.clear">clear</a></code>, but operating on a stateful <code><a href="../../.././Std/Do/SPred/SPred.html#Std.Do.SPred">Std.Do.SPred</a></code> goal.</p><pre><code class="language-lean">example (P Q : SPred σs) : P ⊢ₛ Q → Q := by
  <a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mintro">mintro</a> HP
  <a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mintro">mintro</a> HQ
  <a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mclear">mclear</a> HP
  <a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mexact">mexact</a> HQ
</code></pre><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.mclear" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.mconstructor"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/7c3ca70e29a0806bd4bfc62eae7084bbaf1a303d/src/Std/Tactic/Do/Syntax.lean#L37-L38">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mconstructor"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">mconstructor</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a></div></div><p><code><a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mconstructor">mconstructor</a></code> is like <code>constructor</code>, but operating on a stateful <code><a href="../../.././Std/Do/SPred/SPred.html#Std.Do.SPred">Std.Do.SPred</a></code> goal.</p><pre><code class="language-lean">example (Q : SPred σs) : Q ⊢ₛ Q ∧ Q := by
  <a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mintro">mintro</a> HQ
  <a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mconstructor">mconstructor</a> &lt;;&gt; <a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mexact">mexact</a> HQ
</code></pre><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mconstructor">Lean.Parser.Tactic.mconstructor</a> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../.././Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`Lean.Parser.Tactic.mconstructor</span> <span class="fn">1024</span> <span class="fn">(<a href="../../.././Init/Prelude.html#Lean.ParserDescr.nonReservedSymbol">Lean.ParserDescr.nonReservedSymbol</a> <span class="fn">&quot;mconstructor&quot;</span> <a href="../../.././Init/Prelude.html#Bool.false">false</a>)</span></span></li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.mconstructor" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.mexact"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/7c3ca70e29a0806bd4bfc62eae7084bbaf1a303d/src/Std/Tactic/Do/Syntax.lean#L40-L41">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mexact"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">mexact</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a></div></div><p><code><a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mexact">mexact</a></code> is like <code>exact</code>, but operating on a stateful <code><a href="../../.././Std/Do/SPred/SPred.html#Std.Do.SPred">Std.Do.SPred</a></code> goal.</p><pre><code class="language-lean">example (Q : SPred σs) : Q ⊢ₛ Q := by
  <a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mstart">mstart</a>
  <a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mintro">mintro</a> HQ
  <a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mexact">mexact</a> HQ
</code></pre><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.mexact" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.mexfalso"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/7c3ca70e29a0806bd4bfc62eae7084bbaf1a303d/src/Std/Tactic/Do/Syntax.lean#L43-L44">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mexfalso"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">mexfalso</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a></div></div><p><code><a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mexfalso">mexfalso</a></code> is like <code>exfalso</code>, but operating on a stateful <code><a href="../../.././Std/Do/SPred/SPred.html#Std.Do.SPred">Std.Do.SPred</a></code> goal.</p><pre><code class="language-lean">example (P : SPred σs) : ⌜False⌝ ⊢ₛ P := by
  <a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mintro">mintro</a> HP
  <a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mexfalso">mexfalso</a>
  <a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mexact">mexact</a> HP
</code></pre><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mexfalso">Lean.Parser.Tactic.mexfalso</a> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../.././Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`Lean.Parser.Tactic.mexfalso</span> <span class="fn">1024</span> <span class="fn">(<a href="../../.././Init/Prelude.html#Lean.ParserDescr.nonReservedSymbol">Lean.ParserDescr.nonReservedSymbol</a> <span class="fn">&quot;mexfalso&quot;</span> <a href="../../.././Init/Prelude.html#Bool.false">false</a>)</span></span></li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.mexfalso" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.mexists"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/7c3ca70e29a0806bd4bfc62eae7084bbaf1a303d/src/Std/Tactic/Do/Syntax.lean#L46-L47">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mexists"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">mexists</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a></div></div><p><code><a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mexists">mexists</a></code> is like <code>exists</code>, but operating on a stateful <code><a href="../../.././Std/Do/SPred/SPred.html#Std.Do.SPred">Std.Do.SPred</a></code> goal.</p><pre><code class="language-lean">example (ψ : <a href="../../.././Init/Prelude.html#Nat">Nat</a> → SPred σs) : ψ 42 ⊢ₛ ∃ x, ψ x := by
  <a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mintro">mintro</a> H
  <a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mexists">mexists</a> 42
</code></pre><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.mexists" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.mframe"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/7c3ca70e29a0806bd4bfc62eae7084bbaf1a303d/src/Std/Tactic/Do/Syntax.lean#L49-L50">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mframe"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">mframe</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a></div></div><p><code><a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mframe">mframe</a></code> infers which hypotheses from the stateful context can be moved into the pure context.
This is useful because pure hypotheses &quot;survive&quot; the next application of modus ponens
(<code><a href="../../.././Std/Do/SPred/DerivedLaws.html#Std.Do.SPred.mp">Std.Do.SPred.mp</a></code>) and transitivity (<code><a href="../../.././Std/Do/SPred/Laws.html#Std.Do.SPred.entails.trans">Std.Do.SPred.entails.trans</a></code>).</p><p>It is used as part of the <code><a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mspec">mspec</a></code> tactic.</p><pre><code class="language-lean">example (P Q : SPred σs) : ⊢ₛ ⌜p⌝ ∧ Q ∧ ⌜q⌝ ∧ ⌜r⌝ ∧ P ∧ ⌜s⌝ ∧ ⌜t⌝ → Q := by
  <a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mintro">mintro</a> _
  <a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mframe">mframe</a>
  /- `h : p ∧ q ∧ r ∧ s ∧ t` in the <a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.MCasesPat.pure">pure</a> context -/
  <a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mcases">mcases</a> h with hP
  <a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mexact">mexact</a> h
</code></pre><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mframe">Lean.Parser.Tactic.mframe</a> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../.././Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`Lean.Parser.Tactic.mframe</span> <span class="fn">1024</span> <span class="fn">(<a href="../../.././Init/Prelude.html#Lean.ParserDescr.nonReservedSymbol">Lean.ParserDescr.nonReservedSymbol</a> <span class="fn">&quot;mframe&quot;</span> <a href="../../.././Init/Prelude.html#Bool.false">false</a>)</span></span></li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.mframe" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.mdup"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/7c3ca70e29a0806bd4bfc62eae7084bbaf1a303d/src/Std/Tactic/Do/Syntax.lean#L52-L53">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mdup"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">mdup</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a></div></div><p>Duplicate a stateful <code><a href="../../.././Std/Do/SPred/SPred.html#Std.Do.SPred">Std.Do.SPred</a></code> hypothesis.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.mdup" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.mhave"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/7c3ca70e29a0806bd4bfc62eae7084bbaf1a303d/src/Std/Tactic/Do/Syntax.lean#L55-L56">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mhave"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">mhave</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a></div></div><p><code><a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mhave">mhave</a></code> is like <code>have</code>, but operating on a stateful <code><a href="../../.././Std/Do/SPred/SPred.html#Std.Do.SPred">Std.Do.SPred</a></code> goal.</p><pre><code class="language-lean">example (P Q : SPred σs) : P ⊢ₛ (P → Q) → Q := by
  <a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mintro">mintro</a> HP HPQ
  <a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mhave">mhave</a> HQ : Q := by <a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mspecialize">mspecialize</a> HPQ HP; <a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mexact">mexact</a> HPQ
  <a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mexact">mexact</a> HQ
</code></pre><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.mhave" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.mreplace"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/7c3ca70e29a0806bd4bfc62eae7084bbaf1a303d/src/Std/Tactic/Do/Syntax.lean#L58-L59">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mreplace"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">mreplace</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a></div></div><p><code><a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mreplace">mreplace</a></code> is like <code>replace</code>, but operating on a stateful <code><a href="../../.././Std/Do/SPred/SPred.html#Std.Do.SPred">Std.Do.SPred</a></code> goal.</p><pre><code class="language-lean">example (P Q : SPred σs) : P ⊢ₛ (P → Q) → Q := by
  <a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mintro">mintro</a> HP HPQ
  <a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mreplace">mreplace</a> HPQ : Q := by <a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mspecialize">mspecialize</a> HPQ HP; <a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mexact">mexact</a> HPQ
  <a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mexact">mexact</a> HPQ
</code></pre><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.mreplace" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.mright"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/7c3ca70e29a0806bd4bfc62eae7084bbaf1a303d/src/Std/Tactic/Do/Syntax.lean#L61-L62">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mright"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">mright</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a></div></div><p><code><a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mright">mright</a></code> is like <code>right</code>, but operating on a stateful <code><a href="../../.././Std/Do/SPred/SPred.html#Std.Do.SPred">Std.Do.SPred</a></code> goal.</p><pre><code class="language-lean">example (P Q : SPred σs) : P ⊢ₛ Q ∨ P := by
  <a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mintro">mintro</a> HP
  <a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mright">mright</a>
  <a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mexact">mexact</a> HP
</code></pre><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mright">Lean.Parser.Tactic.mright</a> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../.././Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`Lean.Parser.Tactic.mright</span> <span class="fn">1024</span> <span class="fn">(<a href="../../.././Init/Prelude.html#Lean.ParserDescr.nonReservedSymbol">Lean.ParserDescr.nonReservedSymbol</a> <span class="fn">&quot;mright&quot;</span> <a href="../../.././Init/Prelude.html#Bool.false">false</a>)</span></span></li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.mright" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.mleft"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/7c3ca70e29a0806bd4bfc62eae7084bbaf1a303d/src/Std/Tactic/Do/Syntax.lean#L64-L65">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mleft"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">mleft</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a></div></div><p><code><a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mleft">mleft</a></code> is like <code>left</code>, but operating on a stateful <code><a href="../../.././Std/Do/SPred/SPred.html#Std.Do.SPred">Std.Do.SPred</a></code> goal.</p><pre><code class="language-lean">example (P Q : SPred σs) : P ⊢ₛ P ∨ Q := by
  <a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mintro">mintro</a> HP
  <a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mleft">mleft</a>
  <a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mexact">mexact</a> HP
</code></pre><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mleft">Lean.Parser.Tactic.mleft</a> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../.././Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`Lean.Parser.Tactic.mleft</span> <span class="fn">1024</span> <span class="fn">(<a href="../../.././Init/Prelude.html#Lean.ParserDescr.nonReservedSymbol">Lean.ParserDescr.nonReservedSymbol</a> <span class="fn">&quot;mleft&quot;</span> <a href="../../.././Init/Prelude.html#Bool.false">false</a>)</span></span></li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.mleft" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.mpure"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/7c3ca70e29a0806bd4bfc62eae7084bbaf1a303d/src/Std/Tactic/Do/Syntax.lean#L67-L68">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mpure"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">mpure</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a></div></div><p><code><a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mpure">mpure</a></code> moves a pure hypothesis from the stateful context into the pure context.</p><pre><code class="language-lean">example (Q : SPred σs) (ψ : φ → ⊢ₛ Q): ⌜φ⌝ ⊢ₛ Q := by
  <a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mintro">mintro</a> Hφ
  <a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mpure">mpure</a> Hφ
  <a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mexact">mexact</a> (ψ Hφ)
</code></pre><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.mpure" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.mpureIntro"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/7c3ca70e29a0806bd4bfc62eae7084bbaf1a303d/src/Std/Tactic/Do/Syntax.lean#L71-L72">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mpureIntro"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">mpureIntro</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a></div></div><p><code>mpure_intro</code> operates on a stateful <code><a href="../../.././Std/Do/SPred/SPred.html#Std.Do.SPred">Std.Do.SPred</a></code> goal of the form <code>P ⊢ₛ ⌜φ⌝</code>.
It leaves the stateful proof mode (thereby discarding <code>P</code>), leaving the regular goal <code>φ</code>.</p><pre><code class="language-lean">theorem simple : ⊢ₛ (⌜True⌝ : SPred σs) := by
  mpure_intro
  exact <a href="../../.././Init/Prelude.html#True.intro">True.intro</a>
</code></pre><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mpureIntro">Lean.Parser.Tactic.mpureIntro</a> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../.././Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`Lean.Parser.Tactic.mpureIntro</span> <span class="fn">1024</span> <span class="fn">(<a href="../../.././Init/Prelude.html#Lean.ParserDescr.nonReservedSymbol">Lean.ParserDescr.nonReservedSymbol</a> <span class="fn">&quot;mpure_intro&quot;</span> <a href="../../.././Init/Prelude.html#Bool.false">false</a>)</span></span></li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.mpureIntro" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.mrevert"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/7c3ca70e29a0806bd4bfc62eae7084bbaf1a303d/src/Std/Tactic/Do/Syntax.lean#L74-L75">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mrevert"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">mrevert</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a></div></div><p><code><a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mrevert">mrevert</a></code> is like <code>revert</code>, but operating on a stateful <code><a href="../../.././Std/Do/SPred/SPred.html#Std.Do.SPred">Std.Do.SPred</a></code> goal.</p><pre><code class="language-lean">example (P Q R : SPred σs) : P ∧ Q ∧ R ⊢ₛ P → R := by
  <a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mintro">mintro</a> ⟨HP, HQ, HR⟩
  <a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mrevert">mrevert</a> HR
  <a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mrevert">mrevert</a> HP
  <a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mintro">mintro</a> HP'
  <a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mintro">mintro</a> HR'
  <a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mexact">mexact</a> HR'
</code></pre><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.mrevert" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.mspecialize"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/7c3ca70e29a0806bd4bfc62eae7084bbaf1a303d/src/Std/Tactic/Do/Syntax.lean#L77-L78">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mspecialize"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">mspecialize</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a></div></div><p><code><a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mspecialize">mspecialize</a></code> is like <code>specialize</code>, but operating on a stateful <code><a href="../../.././Std/Do/SPred/SPred.html#Std.Do.SPred">Std.Do.SPred</a></code> goal.
It specializes a hypothesis from the stateful context with hypotheses from either the pure
or stateful context or pure terms.</p><pre><code class="language-lean">example (P Q : SPred σs) : P ⊢ₛ (P → Q) → Q := by
  <a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mintro">mintro</a> HP HPQ
  <a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mspecialize">mspecialize</a> HPQ HP
  <a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mexact">mexact</a> HPQ

example (y : Nat) (P Q : SPred σs) (Ψ : <a href="../../.././Init/Prelude.html#Nat">Nat</a> → SPred σs) (hP : ⊢ₛ P) : ⊢ₛ Q → (∀ x, P → Q → Ψ x) → Ψ (y + 1) := by
  <a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mintro">mintro</a> HQ HΨ
  <a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mspecialize">mspecialize</a> HΨ (y + 1) hP HQ
  <a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mexact">mexact</a> HΨ
</code></pre><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.mspecialize" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.mspecializePure"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/7c3ca70e29a0806bd4bfc62eae7084bbaf1a303d/src/Std/Tactic/Do/Syntax.lean#L80-L81">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mspecializePure"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">mspecializePure</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a></div></div><p><code>mspecialize_pure</code> is like <code><a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mspecialize">mspecialize</a></code>, but it specializes a hypothesis from the
<em>pure</em> context with hypotheses from either the pure or stateful context or pure terms.</p><pre><code class="language-lean">example (y : Nat) (P Q : SPred σs) (Ψ : <a href="../../.././Init/Prelude.html#Nat">Nat</a> → SPred σs) (hP : ⊢ₛ P) (hΨ : ∀ x, ⊢ₛ P → Q → Ψ x) : ⊢ₛ Q → Ψ (y + 1) := by
  <a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mintro">mintro</a> HQ
  mspecialize_pure (hΨ (y + 1)) hP HQ =&gt; HΨ
  <a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mexact">mexact</a> HΨ
</code></pre><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.mspecializePure" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.mstart"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/7c3ca70e29a0806bd4bfc62eae7084bbaf1a303d/src/Std/Tactic/Do/Syntax.lean#L83-L84">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mstart"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">mstart</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a></div></div><p>Start the stateful proof mode of <code><a href="../../.././Std/Do/SPred/SPred.html#Std.Do.SPred">Std.Do.SPred</a></code>.
This will transform a stateful goal of the form <code>H ⊢ₛ T</code> into <code>⊢ₛ H → T</code>
upon which <code><a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mintro">mintro</a></code> can be used to re-introduce <code>H</code> and give it a name.
It is often more convenient to use <code><a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mintro">mintro</a></code> directly, which will
try <code><a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mstart">mstart</a></code> automatically if necessary.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mstart">Lean.Parser.Tactic.mstart</a> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../.././Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`Lean.Parser.Tactic.mstart</span> <span class="fn">1024</span> <span class="fn">(<a href="../../.././Init/Prelude.html#Lean.ParserDescr.nonReservedSymbol">Lean.ParserDescr.nonReservedSymbol</a> <span class="fn">&quot;mstart&quot;</span> <a href="../../.././Init/Prelude.html#Bool.false">false</a>)</span></span></li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.mstart" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.mstop"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/7c3ca70e29a0806bd4bfc62eae7084bbaf1a303d/src/Std/Tactic/Do/Syntax.lean#L86-L87">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mstop"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">mstop</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a></div></div><p>Stops the stateful proof mode of <code><a href="../../.././Std/Do/SPred/SPred.html#Std.Do.SPred">Std.Do.SPred</a></code>.
This will simply forget all the names given to stateful hypotheses and pretty-print
a bit differently.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mstop">Lean.Parser.Tactic.mstop</a> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../.././Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`Lean.Parser.Tactic.mstop</span> <span class="fn">1024</span> <span class="fn">(<a href="../../.././Init/Prelude.html#Lean.ParserDescr.nonReservedSymbol">Lean.ParserDescr.nonReservedSymbol</a> <span class="fn">&quot;mstop&quot;</span> <a href="../../.././Init/Prelude.html#Bool.false">false</a>)</span></span></li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.mstop" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.mcasesPat.quot"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/7c3ca70e29a0806bd4bfc62eae7084bbaf1a303d/src/Std/Tactic/Do/Syntax.lean#L89-L89">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mcasesPat.quot"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">mcasesPat</span>.<span class="name">quot</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.mcasesPat.quot" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Category.mcasesPat"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/7c3ca70e29a0806bd4bfc62eae7084bbaf1a303d/src/Std/Tactic/Do/Syntax.lean#L89-L89">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Category.mcasesPat"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Category</span>.<span class="name">mcasesPat</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Init/Notation.html#Lean.Parser.Category">Category</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Category.mcasesPat">Lean.Parser.Category.mcasesPat</a> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Init/Notation.html#Lean.Parser.Category.mk">{</a> <a href="../../.././Init/Notation.html#Lean.Parser.Category.mk">}</a></li></ul></details><details id="instances-for-list-Lean.Parser.Category.mcasesPat" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.mcasesPatAlts"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/7c3ca70e29a0806bd4bfc62eae7084bbaf1a303d/src/Std/Tactic/Do/Syntax.lean#L90-L90">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mcasesPatAlts"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">mcasesPatAlts</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.mcasesPatAlts" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.mcasesPat_"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/7c3ca70e29a0806bd4bfc62eae7084bbaf1a303d/src/Std/Tactic/Do/Syntax.lean#L91-L91">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mcasesPat_"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">mcasesPat_</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mcasesPat_">Lean.Parser.Tactic.mcasesPat_</a> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`Lean.Parser.Tactic.mcasesPat_</span> <span class="fn">1022</span> <a href="../../.././Init/Notation.html#Lean.binderIdent">Lean.binderIdent</a></span></li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.mcasesPat_" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.«mcasesPat-»"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/7c3ca70e29a0806bd4bfc62eae7084bbaf1a303d/src/Std/Tactic/Do/Syntax.lean#L92-L92">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.«mcasesPat-»"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">«mcasesPat-»</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.«mcasesPat-»">Lean.Parser.Tactic.«mcasesPat-»</a> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../.././Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`Lean.Parser.Tactic.«mcasesPat-»</span> <span class="fn">1024</span> <span class="fn">(<a href="../../.././Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">&quot;-&quot;</span>)</span></span></li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.«mcasesPat-»" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.«mcasesPat⟨_⟩»"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/7c3ca70e29a0806bd4bfc62eae7084bbaf1a303d/src/Std/Tactic/Do/Syntax.lean#L93-L93">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.«mcasesPat⟨_⟩»"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">«mcasesPat⟨_⟩»</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.«mcasesPat⟨_⟩»" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.«mcasesPat(_)»"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/7c3ca70e29a0806bd4bfc62eae7084bbaf1a303d/src/Std/Tactic/Do/Syntax.lean#L94-L94">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.«mcasesPat(_)»"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">«mcasesPat(_)»</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.«mcasesPat(_)»" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.«mcasesPat⌜_⌝»"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/7c3ca70e29a0806bd4bfc62eae7084bbaf1a303d/src/Std/Tactic/Do/Syntax.lean#L95-L95">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.«mcasesPat⌜_⌝»"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">«mcasesPat⌜_⌝»</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.«mcasesPat⌜_⌝»" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.«mcasesPat□_»"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/7c3ca70e29a0806bd4bfc62eae7084bbaf1a303d/src/Std/Tactic/Do/Syntax.lean#L96-L96">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.«mcasesPat□_»"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">«mcasesPat□_»</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.«mcasesPat□_»">Lean.Parser.Tactic.«mcasesPat□_»</a> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../.././Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`Lean.Parser.Tactic.«mcasesPat□_»</span> <span class="fn">1022</span>
    <span class="fn">(<a href="../../.././Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span> <span class="fn">(<a href="../../.././Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">&quot;□&quot;</span>)</span> <a href="../../.././Init/Notation.html#Lean.binderIdent">Lean.binderIdent</a>)</span></span></li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.«mcasesPat□_»" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.«mcasesPat%_»"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/7c3ca70e29a0806bd4bfc62eae7084bbaf1a303d/src/Std/Tactic/Do/Syntax.lean#L98-L98">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.«mcasesPat%_»"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">«mcasesPat%_»</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.«mcasesPat%_»">Lean.Parser.Tactic.«mcasesPat%_»</a> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../.././Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`Lean.Parser.Tactic.«mcasesPat%_»</span> <span class="fn">1022</span>
    <span class="fn">(<a href="../../.././Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span> <span class="fn">(<a href="../../.././Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">&quot;%&quot;</span>)</span> <a href="../../.././Init/Notation.html#Lean.binderIdent">Lean.binderIdent</a>)</span></span></li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.«mcasesPat%_»" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.«mcasesPat#_»"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/7c3ca70e29a0806bd4bfc62eae7084bbaf1a303d/src/Std/Tactic/Do/Syntax.lean#L99-L99">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.«mcasesPat#_»"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">«mcasesPat#_»</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.«mcasesPat#_»">Lean.Parser.Tactic.«mcasesPat#_»</a> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../.././Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`Lean.Parser.Tactic.«mcasesPat#_»</span> <span class="fn">1022</span>
    <span class="fn">(<a href="../../.././Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span> <span class="fn">(<a href="../../.././Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">&quot;#&quot;</span>)</span> <a href="../../.././Init/Notation.html#Lean.binderIdent">Lean.binderIdent</a>)</span></span></li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.«mcasesPat#_»" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.MCasesPat"><div class="inductive"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/7c3ca70e29a0806bd4bfc62eae7084bbaf1a303d/src/Std/Tactic/Do/Syntax.lean#L101-L108">source</a></div><div class="decl_header"><span class="decl_kind">inductive</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.MCasesPat"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">MCasesPat</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././foundational_types.html">Type</a></div></div><ul class="constructors"><li class="constructor" id="Lean.Parser.Tactic.MCasesPat.one">one<span class="decl_args">
<span class="fn">(<span class="fn">name</span> : <a href="../../.././Init/Prelude.html#Lean.TSyntax">TSyntax</a> <span class="fn">`Lean.binderIdent</span>)</span></span>
 : <a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.MCasesPat">MCasesPat</a></li><li class="constructor" id="Lean.Parser.Tactic.MCasesPat.clear">clear : <a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.MCasesPat">MCasesPat</a></li><li class="constructor" id="Lean.Parser.Tactic.MCasesPat.tuple">tuple<span class="decl_args">
<span class="fn">(<span class="fn">args</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.MCasesPat">MCasesPat</a></span>)</span></span>
 : <a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.MCasesPat">MCasesPat</a></li><li class="constructor" id="Lean.Parser.Tactic.MCasesPat.alts">alts<span class="decl_args">
<span class="fn">(<span class="fn">args</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.MCasesPat">MCasesPat</a></span>)</span></span>
 : <a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.MCasesPat">MCasesPat</a></li><li class="constructor" id="Lean.Parser.Tactic.MCasesPat.pure">pure<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <a href="../../.././Init/Prelude.html#Lean.TSyntax">TSyntax</a> <span class="fn">`Lean.binderIdent</span>)</span></span>
 : <a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.MCasesPat">MCasesPat</a></li><li class="constructor" id="Lean.Parser.Tactic.MCasesPat.stateful">stateful<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <a href="../../.././Init/Prelude.html#Lean.TSyntax">TSyntax</a> <span class="fn">`Lean.binderIdent</span>)</span></span>
 : <a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.MCasesPat">MCasesPat</a></li></ul><details id="instances-for-list-Lean.Parser.Tactic.MCasesPat" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.instReprMCasesPat"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/7c3ca70e29a0806bd4bfc62eae7084bbaf1a303d/src/Std/Tactic/Do/Syntax.lean#L108-L108">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.instReprMCasesPat"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">instReprMCasesPat</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Data/Repr.html#Repr">Repr</a> <a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.MCasesPat">MCasesPat</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.instReprMCasesPat">Lean.Parser.Tactic.instReprMCasesPat</a> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Init/Data/Repr.html#Repr.mk">{</a> <span class="fn">reprPrec</span> := <a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.reprMCasesPat._@.Std.Tactic.Do.Syntax._hyg.960">Lean.Parser.Tactic.reprMCasesPat✝</a> <a href="../../.././Init/Data/Repr.html#Repr.mk">}</a></li></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.instInhabitedMCasesPat"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/7c3ca70e29a0806bd4bfc62eae7084bbaf1a303d/src/Std/Tactic/Do/Syntax.lean#L108-L108">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.instInhabitedMCasesPat"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">instInhabitedMCasesPat</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Prelude.html#Inhabited">Inhabited</a> <a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.MCasesPat">MCasesPat</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.instInhabitedMCasesPat">Lean.Parser.Tactic.instInhabitedMCasesPat</a> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Init/Prelude.html#Inhabited.mk">{</a> <span class="fn">default</span> := <span class="fn"><a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.MCasesPat.one">Lean.Parser.Tactic.MCasesPat.one</a> <a href="../../.././Init/Prelude.html#Inhabited.default">default</a></span> <a href="../../.././Init/Prelude.html#Inhabited.mk">}</a></li></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.MCasesPat.parse"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/7c3ca70e29a0806bd4bfc62eae7084bbaf1a303d/src/Std/Tactic/Do/Syntax.lean#L110-L128">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.MCasesPat.parse"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">MCasesPat</span>.<span class="name">parse</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">pat</span> : <a href="../../.././Init/Prelude.html#Lean.TSyntax">TSyntax</a> <span class="fn">`mcasesPat</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Prelude.html#Lean.MacroM">MacroM</a> <a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.MCasesPat">MCasesPat</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.MCasesPat.parse" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.MCasesPat.parse.go"><div class="opaque"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/7c3ca70e29a0806bd4bfc62eae7084bbaf1a303d/src/Std/Tactic/Do/Syntax.lean#L115-L122">source</a></div><div class="decl_header"><span class="decl_kind">partial def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.MCasesPat.parse.go"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">MCasesPat</span>.<span class="name">parse</span>.<span class="name">go</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Prelude.html#Lean.TSyntax">TSyntax</a> <span class="fn">`mcasesPat</span> → <span class="fn"><a href="../../.././Init/Prelude.html#Option">Option</a> <a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.MCasesPat">MCasesPat</a></span></span></div></div></div></div><div class="decl" id="Lean.Parser.Tactic.MCasesPat.parse.goAlts"><div class="opaque"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/7c3ca70e29a0806bd4bfc62eae7084bbaf1a303d/src/Std/Tactic/Do/Syntax.lean#L123-L128">source</a></div><div class="decl_header"><span class="decl_kind">partial def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.MCasesPat.parse.goAlts"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">MCasesPat</span>.<span class="name">parse</span>.<span class="name">goAlts</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Prelude.html#Lean.TSyntax">TSyntax</a> <span class="fn">`Lean.Parser.Tactic.mcasesPatAlts</span> → <span class="fn"><a href="../../.././Init/Prelude.html#Option">Option</a> <a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.MCasesPat">MCasesPat</a></span></span></div></div></div></div><div class="decl" id="Lean.Parser.Tactic.mcases"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/7c3ca70e29a0806bd4bfc62eae7084bbaf1a303d/src/Std/Tactic/Do/Syntax.lean#L130-L131">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mcases"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">mcases</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a></div></div><p>Like <code>rcases</code>, but operating on stateful <code><a href="../../.././Std/Do/SPred/SPred.html#Std.Do.SPred">Std.Do.SPred</a></code> goals.
Example: Given a goal <code>h : (P ∧ (Q ∨ R) ∧ (Q → R)) ⊢ₛ R</code>,
<code><a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mcases">mcases</a> h with ⟨-, ⟨hq | hr⟩, hqr⟩</code> will yield two goals:
<code>(hq : Q, hqr : Q → R) ⊢ₛ R</code> and <code>(hr : R) ⊢ₛ R</code>.</p><p>That is, <code><a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mcases">mcases</a> h with pat</code> has the following semantics, based on <code>pat</code>:</p><ul>
<li><code>pat=□h'</code> renames <code>h</code> to <code>h'</code> in the stateful context, regardless of whether <code>h</code> is pure</li>
<li><code>pat=⌜h'⌝</code> introduces <code>h' : φ</code>  to the pure local context if <code>h : ⌜φ⌝</code>
(c.f. <code>Lean.Elab.Tactic.Do.ProofMode.IsPure</code>)</li>
<li><code>pat=h'</code> is like <code>pat=⌜h'⌝</code> if <code>h</code> is pure
(c.f. <code>Lean.Elab.Tactic.Do.ProofMode.IsPure</code>), otherwise it is like <code>pat=□h'</code>.</li>
<li><code>pat=_</code> renames <code>h</code> to an inaccessible name</li>
<li><code>pat=-</code> discards <code>h</code></li>
<li><code>⟨pat₁, pat₂⟩</code> matches on conjunctions and existential quantifiers and recurses via
<code>pat₁</code> and <code>pat₂</code>.</li>
<li><code>⟨pat₁ | pat₂⟩</code> matches on disjunctions, matching the left alternative via <code>pat₁</code> and the right
alternative via <code>pat₂</code>.</li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.mcases" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Category.mrefinePat"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/7c3ca70e29a0806bd4bfc62eae7084bbaf1a303d/src/Std/Tactic/Do/Syntax.lean#L133-L133">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Category.mrefinePat"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Category</span>.<span class="name">mrefinePat</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Init/Notation.html#Lean.Parser.Category">Category</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Category.mrefinePat">Lean.Parser.Category.mrefinePat</a> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Init/Notation.html#Lean.Parser.Category.mk">{</a> <a href="../../.././Init/Notation.html#Lean.Parser.Category.mk">}</a></li></ul></details><details id="instances-for-list-Lean.Parser.Category.mrefinePat" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.mrefinePat.quot"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/7c3ca70e29a0806bd4bfc62eae7084bbaf1a303d/src/Std/Tactic/Do/Syntax.lean#L133-L133">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mrefinePat.quot"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">mrefinePat</span>.<span class="name">quot</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.mrefinePat.quot" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.mrefinePat_"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/7c3ca70e29a0806bd4bfc62eae7084bbaf1a303d/src/Std/Tactic/Do/Syntax.lean#L134-L134">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mrefinePat_"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">mrefinePat_</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mrefinePat_">Lean.Parser.Tactic.mrefinePat_</a> <a href="../../.././Init/Prelude.html#Eq">=</a> <span class="fn"><a href="../../.././Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`Lean.Parser.Tactic.mrefinePat_</span> <span class="fn">1022</span> <a href="../../.././Init/Notation.html#Lean.binderIdent">Lean.binderIdent</a></span></li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.mrefinePat_" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.mrefinePats"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/7c3ca70e29a0806bd4bfc62eae7084bbaf1a303d/src/Std/Tactic/Do/Syntax.lean#L135-L135">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mrefinePats"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">mrefinePats</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.mrefinePats" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.«mrefinePat⟨_⟩»"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/7c3ca70e29a0806bd4bfc62eae7084bbaf1a303d/src/Std/Tactic/Do/Syntax.lean#L136-L136">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.«mrefinePat⟨_⟩»"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">«mrefinePat⟨_⟩»</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.«mrefinePat⟨_⟩»" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.«mrefinePat(_)»"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/7c3ca70e29a0806bd4bfc62eae7084bbaf1a303d/src/Std/Tactic/Do/Syntax.lean#L137-L137">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.«mrefinePat(_)»"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">«mrefinePat(_)»</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.«mrefinePat(_)»" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.«mrefinePat⌜_⌝»"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/7c3ca70e29a0806bd4bfc62eae7084bbaf1a303d/src/Std/Tactic/Do/Syntax.lean#L138-L138">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.«mrefinePat⌜_⌝»"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">«mrefinePat⌜_⌝»</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.«mrefinePat⌜_⌝»" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.«mrefinePat□_»"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/7c3ca70e29a0806bd4bfc62eae7084bbaf1a303d/src/Std/Tactic/Do/Syntax.lean#L139-L139">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.«mrefinePat□_»"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">«mrefinePat□_»</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.«mrefinePat□_»">Lean.Parser.Tactic.«mrefinePat□_»</a> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../.././Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`Lean.Parser.Tactic.«mrefinePat□_»</span> <span class="fn">1022</span>
    <span class="fn">(<a href="../../.././Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span> <span class="fn">(<a href="../../.././Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">&quot;□&quot;</span>)</span> <a href="../../.././Init/Notation.html#Lean.binderIdent">Lean.binderIdent</a>)</span></span></li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.«mrefinePat□_»" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.mrefinePat?_"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/7c3ca70e29a0806bd4bfc62eae7084bbaf1a303d/src/Std/Tactic/Do/Syntax.lean#L140-L140">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mrefinePat?_"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">mrefinePat?_</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mrefinePat?_">Lean.Parser.Tactic.mrefinePat?_</a> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../.././Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`Lean.Parser.Tactic.mrefinePat?_</span> <span class="fn">1022</span>
    <span class="fn">(<a href="../../.././Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span> <span class="fn">(<a href="../../.././Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">&quot;?&quot;</span>)</span> <a href="../../.././Init/Notation.html#Lean.binderIdent">Lean.binderIdent</a>)</span></span></li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.mrefinePat?_" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.«mrefinePat%_»"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/7c3ca70e29a0806bd4bfc62eae7084bbaf1a303d/src/Std/Tactic/Do/Syntax.lean#L142-L142">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.«mrefinePat%_»"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">«mrefinePat%_»</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.«mrefinePat%_»">Lean.Parser.Tactic.«mrefinePat%_»</a> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../.././Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`Lean.Parser.Tactic.«mrefinePat%_»</span> <span class="fn">1022</span>
    <span class="fn">(<a href="../../.././Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span> <span class="fn">(<a href="../../.././Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">&quot;%&quot;</span>)</span> <span class="fn">(<a href="../../.././Init/Prelude.html#Lean.ParserDescr.cat">Lean.ParserDescr.cat</a> <span class="fn">`term</span> <span class="fn">0</span>)</span>)</span></span></li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.«mrefinePat%_»" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.«mrefinePat#_»"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/7c3ca70e29a0806bd4bfc62eae7084bbaf1a303d/src/Std/Tactic/Do/Syntax.lean#L143-L143">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.«mrefinePat#_»"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">«mrefinePat#_»</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.«mrefinePat#_»">Lean.Parser.Tactic.«mrefinePat#_»</a> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../.././Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`Lean.Parser.Tactic.«mrefinePat#_»</span> <span class="fn">1022</span>
    <span class="fn">(<a href="../../.././Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span> <span class="fn">(<a href="../../.././Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">&quot;#&quot;</span>)</span> <a href="../../.././Init/Notation.html#Lean.binderIdent">Lean.binderIdent</a>)</span></span></li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.«mrefinePat#_»" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.MRefinePat"><div class="inductive"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/7c3ca70e29a0806bd4bfc62eae7084bbaf1a303d/src/Std/Tactic/Do/Syntax.lean#L145-L151">source</a></div><div class="decl_header"><span class="decl_kind">inductive</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.MRefinePat"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">MRefinePat</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././foundational_types.html">Type</a></div></div><ul class="constructors"><li class="constructor" id="Lean.Parser.Tactic.MRefinePat.one">one<span class="decl_args">
<span class="fn">(<span class="fn">name</span> : <a href="../../.././Init/Prelude.html#Lean.TSyntax">TSyntax</a> <span class="fn">`Lean.binderIdent</span>)</span></span>
 : <a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.MRefinePat">MRefinePat</a></li><li class="constructor" id="Lean.Parser.Tactic.MRefinePat.tuple">tuple<span class="decl_args">
<span class="fn">(<span class="fn">args</span> : <span class="fn"><a href="../../.././Init/Prelude.html#List">List</a> <a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.MRefinePat">MRefinePat</a></span>)</span></span>
 : <a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.MRefinePat">MRefinePat</a></li><li class="constructor" id="Lean.Parser.Tactic.MRefinePat.pure">pure<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <a href="../../.././Init/Prelude.html#Lean.TSyntax">TSyntax</a> <span class="fn">`term</span>)</span></span>
 : <a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.MRefinePat">MRefinePat</a></li><li class="constructor" id="Lean.Parser.Tactic.MRefinePat.stateful">stateful<span class="decl_args">
<span class="fn">(<span class="fn">h</span> : <a href="../../.././Init/Prelude.html#Lean.TSyntax">TSyntax</a> <span class="fn">`Lean.binderIdent</span>)</span></span>
 : <a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.MRefinePat">MRefinePat</a></li><li class="constructor" id="Lean.Parser.Tactic.MRefinePat.hole">hole<span class="decl_args">
<span class="fn">(<span class="fn">name</span> : <a href="../../.././Init/Prelude.html#Lean.TSyntax">TSyntax</a> <span class="fn">`Lean.binderIdent</span>)</span></span>
 : <a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.MRefinePat">MRefinePat</a></li></ul><details id="instances-for-list-Lean.Parser.Tactic.MRefinePat" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.instReprMRefinePat"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/7c3ca70e29a0806bd4bfc62eae7084bbaf1a303d/src/Std/Tactic/Do/Syntax.lean#L151-L151">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.instReprMRefinePat"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">instReprMRefinePat</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Data/Repr.html#Repr">Repr</a> <a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.MRefinePat">MRefinePat</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.instReprMRefinePat">Lean.Parser.Tactic.instReprMRefinePat</a> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Init/Data/Repr.html#Repr.mk">{</a> <span class="fn">reprPrec</span> := <a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.reprMRefinePat._@.Std.Tactic.Do.Syntax._hyg.2212">Lean.Parser.Tactic.reprMRefinePat✝</a> <a href="../../.././Init/Data/Repr.html#Repr.mk">}</a></li></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.instInhabitedMRefinePat"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/7c3ca70e29a0806bd4bfc62eae7084bbaf1a303d/src/Std/Tactic/Do/Syntax.lean#L151-L151">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.instInhabitedMRefinePat"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">instInhabitedMRefinePat</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Prelude.html#Inhabited">Inhabited</a> <a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.MRefinePat">MRefinePat</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.instInhabitedMRefinePat">Lean.Parser.Tactic.instInhabitedMRefinePat</a> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Init/Prelude.html#Inhabited.mk">{</a> <span class="fn">default</span> := <span class="fn"><a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.MRefinePat.one">Lean.Parser.Tactic.MRefinePat.one</a> <a href="../../.././Init/Prelude.html#Inhabited.default">default</a></span> <a href="../../.././Init/Prelude.html#Inhabited.mk">}</a></li></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.MRefinePat.parse"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/7c3ca70e29a0806bd4bfc62eae7084bbaf1a303d/src/Std/Tactic/Do/Syntax.lean#L153-L165">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.MRefinePat.parse"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">MRefinePat</span>.<span class="name">parse</span></a></span><span class="decl_args">
<span class="fn">(<span class="fn">pat</span> : <a href="../../.././Init/Prelude.html#Lean.TSyntax">TSyntax</a> <span class="fn">`mrefinePat</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Prelude.html#Lean.MacroM">MacroM</a> <a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.MRefinePat">MRefinePat</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.MRefinePat.parse" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.MRefinePat.parse.go"><div class="opaque"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/7c3ca70e29a0806bd4bfc62eae7084bbaf1a303d/src/Std/Tactic/Do/Syntax.lean#L158-L165">source</a></div><div class="decl_header"><span class="decl_kind">partial def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.MRefinePat.parse.go"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">MRefinePat</span>.<span class="name">parse</span>.<span class="name">go</span></a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href="../../.././Init/Prelude.html#Lean.TSyntax">TSyntax</a> <span class="fn">`mrefinePat</span> → <span class="fn"><a href="../../.././Init/Prelude.html#Option">Option</a> <a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.MRefinePat">MRefinePat</a></span></span></div></div></div></div><div class="decl" id="Lean.Parser.Tactic.mrefine"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/7c3ca70e29a0806bd4bfc62eae7084bbaf1a303d/src/Std/Tactic/Do/Syntax.lean#L167-L168">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mrefine"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">mrefine</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a></div></div><p>Like <code>refine</code>, but operating on stateful <code><a href="../../.././Std/Do/SPred/SPred.html#Std.Do.SPred">Std.Do.SPred</a></code> goals.</p><pre><code class="language-lean">example (P Q R : SPred σs) : (P ∧ Q ∧ R) ⊢ₛ P ∧ R := by
  <a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mintro">mintro</a> ⟨HP, HQ, HR⟩
  <a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mrefine">mrefine</a> ⟨HP, HR⟩

example (ψ : <a href="../../.././Init/Prelude.html#Nat">Nat</a> → SPred σs) : ψ 42 ⊢ₛ ∃ x, ψ x := by
  <a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mintro">mintro</a> H
  <a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mrefine">mrefine</a> ⟨⌜42⌝, H⟩
</code></pre><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.mrefine" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Category.mintroPat"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/7c3ca70e29a0806bd4bfc62eae7084bbaf1a303d/src/Std/Tactic/Do/Syntax.lean#L170-L170">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Category.mintroPat"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Category</span>.<span class="name">mintroPat</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Init/Notation.html#Lean.Parser.Category">Category</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Category.mintroPat">Lean.Parser.Category.mintroPat</a> <a href="../../.././Init/Prelude.html#Eq">=</a> <a href="../../.././Init/Notation.html#Lean.Parser.Category.mk">{</a> <a href="../../.././Init/Notation.html#Lean.Parser.Category.mk">}</a></li></ul></details><details id="instances-for-list-Lean.Parser.Category.mintroPat" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.mintroPat.quot"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/7c3ca70e29a0806bd4bfc62eae7084bbaf1a303d/src/Std/Tactic/Do/Syntax.lean#L170-L170">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mintroPat.quot"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">mintroPat</span>.<span class="name">quot</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.mintroPat.quot" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.mintroPat_"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/7c3ca70e29a0806bd4bfc62eae7084bbaf1a303d/src/Std/Tactic/Do/Syntax.lean#L171-L171">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mintroPat_"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">mintroPat_</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mintroPat_">Lean.Parser.Tactic.mintroPat_</a> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../.././Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`Lean.Parser.Tactic.mintroPat_</span> <span class="fn">1022</span> <span class="fn">(<a href="../../.././Init/Prelude.html#Lean.ParserDescr.cat">Lean.ParserDescr.cat</a> <span class="fn">`mcasesPat</span> <span class="fn">0</span>)</span></span></li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.mintroPat_" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.«mintroPat∀_»"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/7c3ca70e29a0806bd4bfc62eae7084bbaf1a303d/src/Std/Tactic/Do/Syntax.lean#L172-L172">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.«mintroPat∀_»"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">«mintroPat∀_»</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.«mintroPat∀_»">Lean.Parser.Tactic.«mintroPat∀_»</a> <a href="../../.././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="../../.././Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`Lean.Parser.Tactic.«mintroPat∀_»</span> <span class="fn">1022</span>
    <span class="fn">(<a href="../../.././Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span> <span class="fn">(<a href="../../.././Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">&quot;∀&quot;</span>)</span> <a href="../../.././Init/Notation.html#Lean.binderIdent">Lean.binderIdent</a>)</span></span></li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.«mintroPat∀_»" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.mintro"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/7c3ca70e29a0806bd4bfc62eae7084bbaf1a303d/src/Std/Tactic/Do/Syntax.lean#L174-L175">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mintro"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">mintro</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a></div></div><p>Like <code>intro</code>, but introducing stateful hypotheses into the stateful context of the <code><a href="../../.././Std/Do/SPred/SPred.html#Std.Do.SPred">Std.Do.SPred</a></code>
proof mode.
That is, given a stateful goal <code>(hᵢ : Hᵢ)* ⊢ₛ P → T</code>, <code><a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mintro">mintro</a> h</code> transforms
into <code>(hᵢ : Hᵢ)*, (h : P) ⊢ₛ T</code>.</p><p>Furthermore, <code><a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mintro">mintro</a> ∀s</code> is like <code>intro s</code>, but preserves the stateful goal.
That is, <code><a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mintro">mintro</a> ∀s</code> brings the topmost state variable <code>s:σ</code> in scope and transforms
<code>(hᵢ : Hᵢ)* ⊢ₛ T</code> (where the entailment is in <code><a href="../../.././Std/Do/SPred/SPred.html#Std.Do.SPred">Std.Do.SPred</a> (σ::σs)</code>) into
<code>(hᵢ : Hᵢ s)* ⊢ₛ T s</code> (where the entailment is in <code><a href="../../.././Std/Do/SPred/SPred.html#Std.Do.SPred">Std.Do.SPred</a> σs</code>).</p><p>Beyond that, <code><a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mintro">mintro</a></code> supports the full syntax of <code><a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mcases">mcases</a></code> patterns
(<code><a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mintro">mintro</a> pat = (mintro h; <a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mcases">mcases</a> h with pat</code>), and can perform multiple
introductions in sequence.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.mintro" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.mspecNoBind"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/7c3ca70e29a0806bd4bfc62eae7084bbaf1a303d/src/Std/Tactic/Do/Syntax.lean#L186-L194">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mspecNoBind"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">mspecNoBind</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a></div></div><p><code>mspec_no_simp $spec</code> first tries to decompose <code><a href="../../.././Init/Prelude.html#Bind.bind">Bind.bind</a></code>s before applying <code>$spec</code>.
This variant of <code>mspec_no_simp</code> does not; <code>mspec_no_bind $spec</code> is defined as</p><pre><code>try with_reducible mspec_no_bind <a href="../../.././Std/Do/Triple/SpecLemmas.html#Std.Do.Spec.bind">Std.Do.Spec.bind</a>
mspec_no_bind $spec
</code></pre><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.mspecNoBind" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.mspecNoSimp"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/7c3ca70e29a0806bd4bfc62eae7084bbaf1a303d/src/Std/Tactic/Do/Syntax.lean#L207-L208">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mspecNoSimp"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">mspecNoSimp</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a></div></div><p>Like <code><a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mspec">mspec</a></code>, but does not attempt slight simplification and closing of trivial sub-goals.
<code><a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mspec">mspec</a> $spec</code> is roughly (the set of simp lemmas below might not be up to date)</p><pre><code>mspec_no_simp $spec
all_goals
  ((try simp only [SPred.true_intro_simp, SPred.true_intro_simp_nil, SVal.curry_cons,
                   SVal.uncurry_cons, SVal.getThe_here, SVal.getThe_there]);
   (try mpure_intro; trivial))
</code></pre><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.mspecNoSimp" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.mspec"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/7c3ca70e29a0806bd4bfc62eae7084bbaf1a303d/src/Std/Tactic/Do/Syntax.lean#L211-L220">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mspec"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">mspec</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a></div></div><p><code><a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mspec">mspec</a></code> is an <code>apply</code>-like tactic that applies a Hoare triple specification to the target of the
stateful goal.</p><p>Given a stateful goal <code>H ⊢ₛ wp⟦prog⟧.apply Q'</code>, <code><a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mspec">mspec</a> foo_spec</code> will instantiate
<code>foo_spec : ... → ⦃P⦄ foo ⦃Q⦄</code>, match <code>foo</code> against <code>prog</code> and produce subgoals for
the verification conditions <code>?pre : H ⊢ₛ P</code> and <code>?post : Q ⊢ₚ Q'</code>.</p><ul>
<li>If <code>prog = x &gt;&gt;= f</code>, then <code><a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mspec">mspec</a> Specs.bind</code> is tried first so that <code>foo</code> is matched against <code>x</code>
instead. Tactic <code>mspec_no_bind</code> does not attempt to do this decomposition.</li>
<li>If <code>?pre</code> or <code>?post</code> follow by <code>.<a href="../../.././Init/Prelude.html#rfl">rfl</a></code>, then they are discharged automatically.</li>
<li><code>?post</code> is automatically simplified into constituent <code>⊢ₛ</code> entailments on
success and failure continuations.</li>
<li><code>?pre</code> and <code>?post.*</code> goals introduce their stateful hypothesis as <code>h</code>.</li>
<li>Any uninstantiated MVar arising from instantiation of <code>foo_spec</code> becomes a new subgoal.</li>
<li>If the goal looks like <code>fun s =&gt; _ ⊢ₛ _</code> then <code><a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mspec">mspec</a></code> will first <code><a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mintro">mintro</a> ∀s</code>.</li>
<li>If <code>P</code> has schematic variables that can be instantiated by doing <code><a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mintro">mintro</a> ∀s</code>, for example
<code>foo_spec : ∀(n:Nat), ⦃⌜n = ‹Nat›ₛ⌝⦄ foo ⦃Q⦄</code>, then <code><a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mspec">mspec</a></code> will do <code><a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mintro">mintro</a> ∀s</code> first to
instantiate <code>n = s</code>.</li>
<li>Right before applying the spec, the <code><a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mframe">mframe</a></code> tactic is used, which has the following effect:
Any hypothesis <code>Hᵢ</code> in the goal <code>h₁:H₁, h₂:H₂, ..., hₙ:Hₙ ⊢ₛ T</code> that is
pure (i.e., equivalent to some <code>⌜φᵢ⌝</code>) will be moved into the pure context as <code>hᵢ:φᵢ</code>.</li>
</ul><p>Additionally, <code><a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mspec">mspec</a></code> can be used without arguments or with a term argument:</p><ul>
<li><code><a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mspec">mspec</a></code> without argument will try and look up a spec for <code>x</code> registered with <code>@[spec]</code>.</li>
<li><code><a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mspec">mspec</a> (foo_spec blah ?bleh)</code> will elaborate its argument as a term with expected type
<code>⦃?P⦄ x ⦃?Q⦄</code> and introduce <code>?bleh</code> as a subgoal.
This is useful to pass an invariant to e.g., <code>Specs.forIn_list</code> and leave the inductive step
as a hole.</li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.mspec" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.mvcgen"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/7c3ca70e29a0806bd4bfc62eae7084bbaf1a303d/src/Std/Tactic/Do/Syntax.lean#L222-L224">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mvcgen"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">mvcgen</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a></div></div><p><code><a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mvcgen">mvcgen</a></code> will break down a Hoare triple proof goal like <code>⦃P⦄ prog ⦃Q⦄</code> into verification conditions,
provided that all functions used in <code>prog</code> have specifications registered with <code>@[spec]</code>.</p><p>A verification condition is an entailment in the stateful logic of <code><a href="../../.././Std/Do/SPred/SPred.html#Std.Do.SPred">Std.Do.SPred</a></code>
in which the original program <code>prog</code> no longer occurs.
Verification conditions are introduced by the <code><a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mspec">mspec</a></code> tactic; see the <code><a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mspec">mspec</a></code> tactic for what they
look like.
When there's no applicable <code><a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mspec">mspec</a></code> spec, <code><a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mvcgen">mvcgen</a></code> will try and rewrite an application
<code>prog = f a b c</code> with the simp set registered via <code>@[spec]</code>.</p><p>When used like <code><a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mvcgen">mvcgen</a> +noLetElim [foo_spec, bar_def, instBEqFloat]</code>, <code><a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mvcgen">mvcgen</a></code> will additionally</p><ul>
<li>add a Hoare triple specification <code>foo_spec : ... → ⦃P⦄ foo ... ⦃Q⦄</code> to <code><a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Attr.spec">spec</a></code> set for a
function <code>foo</code> occurring in <code>prog</code>,</li>
<li>unfold a definition <code>def bar_def ... := ...</code> in <code>prog</code>,</li>
<li>unfold any method of the <code><a href="../../.././Init/Data/Float.html#instBEqFloat">instBEqFloat</a> : <a href="../../.././Init/Prelude.html#BEq">BEq</a> <a href="../../.././Init/Data/Float.html#Float">Float</a></code> instance in <code>prog</code>.</li>
<li>it will no longer substitute away <code>let</code>-expressions that occur at most once in <code>P</code>, <code>Q</code> or <code>prog</code>.</li>
</ul><p>Furthermore, <code><a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mvcgen">mvcgen</a></code> tries to close trivial verification conditions by <code>SPred.entails.<a href="../../.././Init/Prelude.html#rfl">rfl</a></code> or
the tactic sequence <code>try (mpure_intro; trivial)</code>. The variant <code>mvcgen_no_trivial</code> does not do this.</p><p>For debugging purposes there is also <code>mvcgen_step 42</code> which will do at most 42 VC generation
steps. This is useful for bisecting issues with the generated VCs.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.mvcgen" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.mvcgenNoTrivial"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/7c3ca70e29a0806bd4bfc62eae7084bbaf1a303d/src/Std/Tactic/Do/Syntax.lean#L226-L230">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mvcgenNoTrivial"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">mvcgenNoTrivial</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a></div></div><p>Like <code><a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mvcgen">mvcgen</a></code>, but does not attempt to prove trivial VCs via <code>mpure_intro; <a href="../../.././Init/Core.html#trivial">trivial</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.mvcgenNoTrivial" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div><div class="decl" id="Lean.Parser.Tactic.mvcgenStep"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/7c3ca70e29a0806bd4bfc62eae7084bbaf1a303d/src/Std/Tactic/Do/Syntax.lean#L232-L237">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mvcgenStep"><span class="name">Lean</span>.<span class="name">Parser</span>.<span class="name">Tactic</span>.<span class="name">mvcgenStep</span></a></span><span class="decl_args"> :</span><div class="decl_type"><a href="../../.././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a></div></div><p>Like <code>mvcgen_no_trivial</code>, but <code>mvcgen_step 42</code> will only do 42 steps of the VC generation procedure.
This is helpful for bisecting bugs in <code><a href="../../.././Std/Tactic/Do/Syntax.html#Lean.Parser.Tactic.mvcgen">mvcgen</a></code> and tracing its execution.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details><details id="instances-for-list-Lean.Parser.Tactic.mvcgenStep" class="instances-for-list"><summary>Instances For</summary><ul class="instances-for-enum"></ul></details></div></div></main>
<nav class="nav"><iframe src="../../.././navbar.html" class="navframe" frameBorder="0"></iframe></nav></body></html>